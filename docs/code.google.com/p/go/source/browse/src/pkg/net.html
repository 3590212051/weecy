<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		
		<meta name="author" content="Unknown"/>

		 
		<link href="/static/css/bootstrap.css" rel="stylesheet" />
		<title>Go Walker</title>
	</head>

	<body>
		<div class="container">
			<div class="navbar navbar-inverse">
				<div class="navbar-inner">
					<a class="brand" href="/">Go Walker</a>
							<ul class="nav">
			<li><a href="/">Home</a></li>
			<li><a href="/-/index">Index</a></li>
			<li><a href="/-/about">About</a></li>
		</ul>
		<form class="navbar-search pull-right" action="/">
			<input class="search-query" type="text" placeholder="Search" name="q"></input>
		</form>
	</div>
</div>
<div class="flat-well well-small">
	<a href="http://code.google.com/p/go/source/browse/src/pkg/net?name=release"><strong>net:</strong></a> <a href="/code.google.com/p/go/source/browse/src/pkg/">code.google.com/p/go/source/browse/src/pkg/</a><span class="muted">net</span>
	<span class="pull-right"><a href="#_index">Index</a><span class="muted"> | </span><a href="#_files">Files</a><span class="muted"> | </span><a href="#_subdirs">Directories</a></span>
</div>
<h2>package net</h2>
<p><code>import "net"</code></p>
<pre>Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.</pre>
<div>Although the package provides access to low-level networking<br/>primitives, most clients will need only the basic interface provided<br/>by the Dial, Listen, and Accept functions and the associated<br/>Conn and Listener interfaces. The crypto/tls package uses<br/>the same interfaces and similar Dial and Listen functions.<br/><br/>The Dial function connects to a server:<br/><br/>	conn, err := net.Dial("tcp", "google.com:80")<br/>	if err != nil {<br/>		// handle error<br/>	}<br/>	fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")<br/>	status, err := bufio.NewReader(conn).ReadString('\n')<br/>	// ...<br/><br/>The Listen function creates servers:<br/><br/>	ln, err := net.Listen("tcp", ":8080")<br/>	if err != nil {<br/>		// handle error<br/>	}<br/>	for {<br/>		conn, err := ln.Accept()<br/>		if err != nil {<br/>			// handle error<br/>			continue<br/>		}<br/>		go handleConnection(conn)<br/>	}</div>
<p></p>

<h3 id="_index">Index</h3>
<ul class="unstyled">
<li><a href="#_constants">Constants</a></li>
<li><a href="#_variables">Variables</a></li>
<li><a href="#InterfaceAddrs">func InterfaceAddrs() ([]Addr, error)</a></li><li><a href="#Interfaces">func Interfaces() ([]Interface, error)</a></li><li><a href="#JoinHostPort">func JoinHostPort(host, port string) string</a></li><li><a href="#LookupAddr">func LookupAddr(addr string) (name []string, err error)</a></li><li><a href="#LookupCNAME">func LookupCNAME(name string) (cname string, err error)</a></li><li><a href="#LookupHost">func LookupHost(host string) (addrs []string, err error)</a></li><li><a href="#LookupIP">func LookupIP(host string) (addrs []IP, err error)</a></li><li><a href="#LookupMX">func LookupMX(name string) (mx []*MX, err error)</a></li><li><a href="#LookupPort">func LookupPort(network, service string) (port int, err error)</a></li><li><a href="#LookupSRV">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</a></li><li><a href="#LookupTXT">func LookupTXT(name string) (txt []string, err error)</a></li><li><a href="#SplitHostPort">func SplitHostPort(hostport string) (host, port string, err error)</a></li>
<li><a href="#Addr">type Addr</a></li>

<li><a href="#AddrError">type AddrError</a></li>

<ul><li><a href="#Error">func (e *AddrError) Error() string</a></li>
</ul><ul><li><a href="#Temporary">func (e *AddrError) Temporary() bool</a></li>
</ul><ul><li><a href="#Timeout">func (e *AddrError) Timeout() bool</a></li>
</ul><li><a href="#Conn">type Conn</a></li>
<ul><li><a href="#Dial">func Dial(net, addr string) (Conn, error)</a></li></ul><ul><li><a href="#DialTimeout">func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)</a></li></ul><ul><li><a href="#FileConn">func FileConn(f *os.File) (c Conn, err error)</a></li></ul><ul><li><a href="#Pipe">func Pipe() (Conn, Conn)</a></li></ul>
<li><a href="#DNSConfigError">type DNSConfigError</a></li>

<ul><li><a href="#Error">func (e *DNSConfigError) Error() string</a></li>
</ul><ul><li><a href="#Temporary">func (e *DNSConfigError) Temporary() bool</a></li>
</ul><ul><li><a href="#Timeout">func (e *DNSConfigError) Timeout() bool</a></li>
</ul><li><a href="#DNSError">type DNSError</a></li>

<ul><li><a href="#Error">func (e *DNSError) Error() string</a></li>
</ul><ul><li><a href="#Temporary">func (e *DNSError) Temporary() bool</a></li>
</ul><ul><li><a href="#Timeout">func (e *DNSError) Timeout() bool</a></li>
</ul><li><a href="#Error">type Error</a></li>

<li><a href="#Flags">type Flags</a></li>

<ul><li><a href="#String">func (f Flags) String() string</a></li>
</ul><li><a href="#HardwareAddr">type HardwareAddr</a></li>
<ul><li><a href="#ParseMAC">func ParseMAC(s string) (hw HardwareAddr, err error)</a></li></ul>
<ul><li><a href="#String">func (a HardwareAddr) String() string</a></li>
</ul><li><a href="#IP">type IP</a></li>
<ul><li><a href="#IPv4">func IPv4(a, b, c, d byte) IP</a></li></ul><ul><li><a href="#ParseCIDR">func ParseCIDR(s string) (IP, *IPNet, error)</a></li></ul><ul><li><a href="#ParseIP">func ParseIP(s string) IP</a></li></ul>
<ul><li><a href="#DefaultMask">func (ip IP) DefaultMask() IPMask</a></li>
</ul><ul><li><a href="#Equal">func (ip IP) Equal(x IP) bool</a></li>
</ul><ul><li><a href="#IsGlobalUnicast">func (ip IP) IsGlobalUnicast() bool</a></li>
</ul><ul><li><a href="#IsInterfaceLocalMulticast">func (ip IP) IsInterfaceLocalMulticast() bool</a></li>
</ul><ul><li><a href="#IsLinkLocalMulticast">func (ip IP) IsLinkLocalMulticast() bool</a></li>
</ul><ul><li><a href="#IsLinkLocalUnicast">func (ip IP) IsLinkLocalUnicast() bool</a></li>
</ul><ul><li><a href="#IsLoopback">func (ip IP) IsLoopback() bool</a></li>
</ul><ul><li><a href="#IsMulticast">func (ip IP) IsMulticast() bool</a></li>
</ul><ul><li><a href="#IsUnspecified">func (ip IP) IsUnspecified() bool</a></li>
</ul><ul><li><a href="#Mask">func (ip IP) Mask(mask IPMask) IP</a></li>
</ul><ul><li><a href="#String">func (ip IP) String() string</a></li>
</ul><ul><li><a href="#To16">func (ip IP) To16() IP</a></li>
</ul><ul><li><a href="#To4">func (ip IP) To4() IP</a></li>
</ul><li><a href="#IPAddr">type IPAddr</a></li>
<ul><li><a href="#ResolveIPAddr">func ResolveIPAddr(net, addr string) (*IPAddr, error)</a></li></ul>
<ul><li><a href="#Network">func (a *IPAddr) Network() string</a></li>
</ul><ul><li><a href="#String">func (a *IPAddr) String() string</a></li>
</ul><li><a href="#IPConn">type IPConn</a></li>
<ul><li><a href="#DialIP">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</a></li></ul><ul><li><a href="#ListenIP">func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</a></li></ul>
<ul><li><a href="#Close">func (c *IPConn) Close() error</a></li>
</ul><ul><li><a href="#File">func (c *IPConn) File() (f *os.File, err error)</a></li>
</ul><ul><li><a href="#LocalAddr">func (c *IPConn) LocalAddr() Addr</a></li>
</ul><ul><li><a href="#Read">func (c *IPConn) Read(b []byte) (int, error)</a></li>
</ul><ul><li><a href="#ReadFrom">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</a></li>
</ul><ul><li><a href="#ReadFromIP">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</a></li>
</ul><ul><li><a href="#RemoteAddr">func (c *IPConn) RemoteAddr() Addr</a></li>
</ul><ul><li><a href="#SetDeadline">func (c *IPConn) SetDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#SetReadBuffer">func (c *IPConn) SetReadBuffer(bytes int) error</a></li>
</ul><ul><li><a href="#SetReadDeadline">func (c *IPConn) SetReadDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#SetWriteBuffer">func (c *IPConn) SetWriteBuffer(bytes int) error</a></li>
</ul><ul><li><a href="#SetWriteDeadline">func (c *IPConn) SetWriteDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#Write">func (c *IPConn) Write(b []byte) (int, error)</a></li>
</ul><ul><li><a href="#WriteTo">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</a></li>
</ul><ul><li><a href="#WriteToIP">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</a></li>
</ul><li><a href="#IPMask">type IPMask</a></li>
<ul><li><a href="#CIDRMask">func CIDRMask(ones, bits int) IPMask</a></li></ul><ul><li><a href="#IPv4Mask">func IPv4Mask(a, b, c, d byte) IPMask</a></li></ul>
<ul><li><a href="#Size">func (m IPMask) Size() (ones, bits int)</a></li>
</ul><ul><li><a href="#String">func (m IPMask) String() string</a></li>
</ul><li><a href="#IPNet">type IPNet</a></li>

<ul><li><a href="#Contains">func (n *IPNet) Contains(ip IP) bool</a></li>
</ul><ul><li><a href="#Network">func (n *IPNet) Network() string</a></li>
</ul><ul><li><a href="#String">func (n *IPNet) String() string</a></li>
</ul><li><a href="#Interface">type Interface</a></li>
<ul><li><a href="#InterfaceByIndex">func InterfaceByIndex(index int) (*Interface, error)</a></li></ul><ul><li><a href="#InterfaceByName">func InterfaceByName(name string) (*Interface, error)</a></li></ul>
<ul><li><a href="#Addrs">func (ifi *Interface) Addrs() ([]Addr, error)</a></li>
</ul><ul><li><a href="#MulticastAddrs">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</a></li>
</ul><li><a href="#InvalidAddrError">type InvalidAddrError</a></li>

<ul><li><a href="#Error">func (e InvalidAddrError) Error() string</a></li>
</ul><ul><li><a href="#Temporary">func (e InvalidAddrError) Temporary() bool</a></li>
</ul><ul><li><a href="#Timeout">func (e InvalidAddrError) Timeout() bool</a></li>
</ul><li><a href="#Listener">type Listener</a></li>
<ul><li><a href="#FileListener">func FileListener(f *os.File) (l Listener, err error)</a></li></ul><ul><li><a href="#Listen">func Listen(net, laddr string) (Listener, error)</a></li></ul>
<li><a href="#MX">type MX</a></li>

<li><a href="#OpError">type OpError</a></li>

<ul><li><a href="#Error">func (e *OpError) Error() string</a></li>
</ul><ul><li><a href="#Temporary">func (e *OpError) Temporary() bool</a></li>
</ul><ul><li><a href="#Timeout">func (e *OpError) Timeout() bool</a></li>
</ul><li><a href="#PacketConn">type PacketConn</a></li>
<ul><li><a href="#FilePacketConn">func FilePacketConn(f *os.File) (c PacketConn, err error)</a></li></ul><ul><li><a href="#ListenPacket">func ListenPacket(net, addr string) (PacketConn, error)</a></li></ul>
<li><a href="#ParseError">type ParseError</a></li>

<ul><li><a href="#Error">func (e *ParseError) Error() string</a></li>
</ul><li><a href="#SRV">type SRV</a></li>

<li><a href="#TCPAddr">type TCPAddr</a></li>
<ul><li><a href="#ResolveTCPAddr">func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</a></li></ul>
<ul><li><a href="#Network">func (a *TCPAddr) Network() string</a></li>
</ul><ul><li><a href="#String">func (a *TCPAddr) String() string</a></li>
</ul><li><a href="#TCPConn">type TCPConn</a></li>
<ul><li><a href="#DialTCP">func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</a></li></ul>
<ul><li><a href="#Close">func (c *TCPConn) Close() error</a></li>
</ul><ul><li><a href="#CloseRead">func (c *TCPConn) CloseRead() error</a></li>
</ul><ul><li><a href="#CloseWrite">func (c *TCPConn) CloseWrite() error</a></li>
</ul><ul><li><a href="#File">func (c *TCPConn) File() (f *os.File, err error)</a></li>
</ul><ul><li><a href="#LocalAddr">func (c *TCPConn) LocalAddr() Addr</a></li>
</ul><ul><li><a href="#Read">func (c *TCPConn) Read(b []byte) (n int, err error)</a></li>
</ul><ul><li><a href="#ReadFrom">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</a></li>
</ul><ul><li><a href="#RemoteAddr">func (c *TCPConn) RemoteAddr() Addr</a></li>
</ul><ul><li><a href="#SetDeadline">func (c *TCPConn) SetDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#SetKeepAlive">func (c *TCPConn) SetKeepAlive(keepalive bool) error</a></li>
</ul><ul><li><a href="#SetLinger">func (c *TCPConn) SetLinger(sec int) error</a></li>
</ul><ul><li><a href="#SetNoDelay">func (c *TCPConn) SetNoDelay(noDelay bool) error</a></li>
</ul><ul><li><a href="#SetReadBuffer">func (c *TCPConn) SetReadBuffer(bytes int) error</a></li>
</ul><ul><li><a href="#SetReadDeadline">func (c *TCPConn) SetReadDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#SetWriteBuffer">func (c *TCPConn) SetWriteBuffer(bytes int) error</a></li>
</ul><ul><li><a href="#SetWriteDeadline">func (c *TCPConn) SetWriteDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#Write">func (c *TCPConn) Write(b []byte) (n int, err error)</a></li>
</ul><li><a href="#TCPListener">type TCPListener</a></li>
<ul><li><a href="#ListenTCP">func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</a></li></ul>
<ul><li><a href="#Accept">func (l *TCPListener) Accept() (c Conn, err error)</a></li>
</ul><ul><li><a href="#AcceptTCP">func (l *TCPListener) AcceptTCP() (c *TCPConn, err error)</a></li>
</ul><ul><li><a href="#Addr">func (l *TCPListener) Addr() Addr</a></li>
</ul><ul><li><a href="#Close">func (l *TCPListener) Close() error</a></li>
</ul><ul><li><a href="#File">func (l *TCPListener) File() (f *os.File, err error)</a></li>
</ul><ul><li><a href="#SetDeadline">func (l *TCPListener) SetDeadline(t time.Time) error</a></li>
</ul><li><a href="#UDPAddr">type UDPAddr</a></li>
<ul><li><a href="#ResolveUDPAddr">func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</a></li></ul>
<ul><li><a href="#Network">func (a *UDPAddr) Network() string</a></li>
</ul><ul><li><a href="#String">func (a *UDPAddr) String() string</a></li>
</ul><li><a href="#UDPConn">type UDPConn</a></li>
<ul><li><a href="#DialUDP">func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</a></li></ul><ul><li><a href="#ListenMulticastUDP">func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</a></li></ul><ul><li><a href="#ListenUDP">func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</a></li></ul><ul><li><a href="#ListenUnixgram">func ListenUnixgram(net string, laddr *UnixAddr) (*UDPConn, error)</a></li></ul>
<ul><li><a href="#Close">func (c *UDPConn) Close() error</a></li>
</ul><ul><li><a href="#File">func (c *UDPConn) File() (f *os.File, err error)</a></li>
</ul><ul><li><a href="#LocalAddr">func (c *UDPConn) LocalAddr() Addr</a></li>
</ul><ul><li><a href="#Read">func (c *UDPConn) Read(b []byte) (int, error)</a></li>
</ul><ul><li><a href="#ReadFrom">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</a></li>
</ul><ul><li><a href="#ReadFromUDP">func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</a></li>
</ul><ul><li><a href="#RemoteAddr">func (c *UDPConn) RemoteAddr() Addr</a></li>
</ul><ul><li><a href="#SetDeadline">func (c *UDPConn) SetDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#SetReadBuffer">func (c *UDPConn) SetReadBuffer(bytes int) error</a></li>
</ul><ul><li><a href="#SetReadDeadline">func (c *UDPConn) SetReadDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#SetWriteBuffer">func (c *UDPConn) SetWriteBuffer(bytes int) error</a></li>
</ul><ul><li><a href="#SetWriteDeadline">func (c *UDPConn) SetWriteDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#Write">func (c *UDPConn) Write(b []byte) (int, error)</a></li>
</ul><ul><li><a href="#WriteTo">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</a></li>
</ul><ul><li><a href="#WriteToUDP">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</a></li>
</ul><li><a href="#UnixAddr">type UnixAddr</a></li>
<ul><li><a href="#ResolveUnixAddr">func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</a></li></ul>
<ul><li><a href="#Network">func (a *UnixAddr) Network() string</a></li>
</ul><ul><li><a href="#String">func (a *UnixAddr) String() string</a></li>
</ul><li><a href="#UnixConn">type UnixConn</a></li>
<ul><li><a href="#DialUnix">func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</a></li></ul>
<ul><li><a href="#Close">func (c *UnixConn) Close() error</a></li>
</ul><ul><li><a href="#File">func (c *UnixConn) File() (f *os.File, err error)</a></li>
</ul><ul><li><a href="#LocalAddr">func (c *UnixConn) LocalAddr() Addr</a></li>
</ul><ul><li><a href="#Read">func (c *UnixConn) Read(b []byte) (n int, err error)</a></li>
</ul><ul><li><a href="#ReadFrom">func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error)</a></li>
</ul><ul><li><a href="#ReadFromUnix">func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error)</a></li>
</ul><ul><li><a href="#ReadMsgUnix">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</a></li>
</ul><ul><li><a href="#RemoteAddr">func (c *UnixConn) RemoteAddr() Addr</a></li>
</ul><ul><li><a href="#SetDeadline">func (c *UnixConn) SetDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#SetReadBuffer">func (c *UnixConn) SetReadBuffer(bytes int) error</a></li>
</ul><ul><li><a href="#SetReadDeadline">func (c *UnixConn) SetReadDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#SetWriteBuffer">func (c *UnixConn) SetWriteBuffer(bytes int) error</a></li>
</ul><ul><li><a href="#SetWriteDeadline">func (c *UnixConn) SetWriteDeadline(t time.Time) error</a></li>
</ul><ul><li><a href="#Write">func (c *UnixConn) Write(b []byte) (n int, err error)</a></li>
</ul><ul><li><a href="#WriteMsgUnix">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</a></li>
</ul><ul><li><a href="#WriteTo">func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error)</a></li>
</ul><ul><li><a href="#WriteToUnix">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error)</a></li>
</ul><li><a href="#UnixListener">type UnixListener</a></li>
<ul><li><a href="#ListenUnix">func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</a></li></ul>
<ul><li><a href="#Accept">func (l *UnixListener) Accept() (c Conn, err error)</a></li>
</ul><ul><li><a href="#AcceptUnix">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</a></li>
</ul><ul><li><a href="#Addr">func (l *UnixListener) Addr() Addr</a></li>
</ul><ul><li><a href="#Close">func (l *UnixListener) Close() error</a></li>
</ul><ul><li><a href="#File">func (l *UnixListener) File() (f *os.File, err error)</a></li>
</ul><ul><li><a href="#SetDeadline">func (l *UnixListener) SetDeadline(t time.Time) (err error)</a></li>
</ul><li><a href="#UnknownNetworkError">type UnknownNetworkError</a></li>

<ul><li><a href="#Error">func (e UnknownNetworkError) Error() string</a></li>
</ul><ul><li><a href="#Temporary">func (e UnknownNetworkError) Temporary() bool</a></li>
</ul><ul><li><a href="#Timeout">func (e UnknownNetworkError) Timeout() bool</a></li>
</ul></ul>
<h3 id="_constants">Constants</h3>
<pre class="pre-x-scrollable">const (
    IPv4len = 4
    IPv6len = 16
)</pre>
<p></p>
<h3 id="_variables">Variables</h3>
<pre class="pre-x-scrollable">var (
    IPv4bcast     = IPv4(255, 255, 255, 255) // broadcast
    IPv4allsys    = IPv4(224, 0, 0, 1)       // all systems
    IPv4allrouter = IPv4(224, 0, 0, 2)       // all routers
    IPv4zero      = IPv4(0, 0, 0, 0)         // all zeros
)</pre><pre class="pre-x-scrollable">var (
    IPv6zero                   = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    IPv6unspecified            = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    IPv6loopback               = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
    IPv6interfacelocalallnodes = IP{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    IPv6linklocalallnodes      = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    IPv6linklocalallrouters    = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}
)</pre><pre class="pre-x-scrollable">var ErrWriteToConnected = errors.New(&#34;use of WriteTo with pre-connected UDP&#34;)</pre>
<p></p>

	
		<h3 id="InterfaceAddrs">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#88">InterfaceAddrs</a></h3>
		<pre>func InterfaceAddrs() ([]Addr, error)</pre>
		<p>InterfaceAddrs returns a list of the system&#39;s network interface
addresses.
</p>
	
		<h3 id="Interfaces">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#82">Interfaces</a></h3>
		<pre>func Interfaces() ([]Interface, error)</pre>
		<p>Interfaces returns a list of the system&#39;s network interfaces.
</p>
	
		<h3 id="JoinHostPort">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ipsock.go?name=release#92">JoinHostPort</a></h3>
		<pre>func JoinHostPort(host, port string) string</pre>
		<p>JoinHostPort combines host and port into a network address
of the form &#34;host:port&#34; or, if host contains a colon, &#34;[host]:port&#34;.
</p>
	
		<h3 id="LookupAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release#57">LookupAddr</a></h3>
		<pre>func LookupAddr(addr string) (name []string, err error)</pre>
		<p>LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.
</p>
	
		<h3 id="LookupCNAME">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release#28">LookupCNAME</a></h3>
		<pre>func LookupCNAME(name string) (cname string, err error)</pre>
		<p>LookupCNAME returns the canonical DNS host for the given name.
Callers that do not care about the canonical name can call
LookupHost or LookupIP directly; both take care of resolving
the canonical name as part of the lookup.
</p>
	
		<h3 id="LookupHost">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release#9">LookupHost</a></h3>
		<pre>func LookupHost(host string) (addrs []string, err error)</pre>
		<p>LookupHost looks up the given host using the local resolver.
It returns an array of that host&#39;s addresses.
</p>
	
		<h3 id="LookupIP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release#15">LookupIP</a></h3>
		<pre>func LookupIP(host string) (addrs []IP, err error)</pre>
		<p>LookupIP looks up host using the local resolver.
It returns an array of that host&#39;s IPv4 and IPv6 addresses.
</p>
	
		<h3 id="LookupMX">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release#46">LookupMX</a></h3>
		<pre>func LookupMX(name string) (mx []*MX, err error)</pre>
		<p>LookupMX returns the DNS MX records for the given domain name sorted by preference.
</p>
	
		<h3 id="LookupPort">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release#20">LookupPort</a></h3>
		<pre>func LookupPort(network, service string) (port int, err error)</pre>
		<p>LookupPort looks up the port for the given network and service.
</p>
	
		<h3 id="LookupSRV">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release#41">LookupSRV</a></h3>
		<pre>func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</pre>
		<p>LookupSRV tries to resolve an SRV query of the given service,
protocol, and domain name.  The proto is &#34;tcp&#34; or &#34;udp&#34;.
The returned records are sorted by priority and randomized
by weight within a priority.

LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name.  To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly.
</p>
	
		<h3 id="LookupTXT">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release#51">LookupTXT</a></h3>
		<pre>func LookupTXT(name string) (txt []string, err error)</pre>
		<p>LookupTXT returns the DNS TXT records for the given domain name.
</p>
	
		<h3 id="SplitHostPort">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ipsock.go?name=release#67">SplitHostPort</a></h3>
		<pre>func SplitHostPort(hostport string) (host, port string, err error)</pre>
		<p>SplitHostPort splits a network address of the form
&#34;host:port&#34; or &#34;[host]:port&#34; into host and port.
The latter form must be used when host contains a colon.
</p>
	


	
		<h3 id="Addr">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#51">Addr</a></h3>
		<pre class="pre-x-scrollable">type Addr interface {
    Network() string // name of the network
    String() string  // string form of address
}</pre>
		<p>Addr represents a network end point address.
</p>
		
		
	
		<h3 id="AddrError">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#224">AddrError</a></h3>
		<pre class="pre-x-scrollable">type AddrError struct {
    Err  string
    Addr string
}</pre>
		<p></p>
		
		
			<h4 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#229">Error</a></h4>
			<pre>func (e *AddrError) Error() string</pre>
			<p></p>
		
			<h4 id="Temporary">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#240">Temporary</a></h4>
			<pre>func (e *AddrError) Temporary() bool</pre>
			<p></p>
		
			<h4 id="Timeout">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#244">Timeout</a></h4>
			<pre>func (e *AddrError) Timeout() bool</pre>
			<p></p>
		
	
		<h3 id="Conn">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#59">Conn</a></h3>
		<pre class="pre-x-scrollable">type Conn interface {
    // Read reads data from the connection.
    // Read can be made to time out and return a Error with Timeout() == true
    // after a fixed time limit; see SetDeadline and SetReadDeadline.
    Read(b []byte) (n int, err error)

    // Write writes data to the connection.
    // Write can be made to time out and return a Error with Timeout() == true
    // after a fixed time limit; see SetDeadline and SetWriteDeadline.
    Write(b []byte) (n int, err error)

    // Close closes the connection.
    // Any blocked Read or Write operations will be unblocked and return errors.
    Close() error

    // LocalAddr returns the local network address.
    LocalAddr() Addr

    // RemoteAddr returns the remote network address.
    RemoteAddr() Addr

    // SetDeadline sets the read and write deadlines associated
    // with the connection. It is equivalent to calling both
    // SetReadDeadline and SetWriteDeadline.
    //
    // A deadline is an absolute time after which I/O operations
    // fail with a timeout (see type Error) instead of
    // blocking. The deadline applies to all future I/O, not just
    // the immediately following call to Read or Write.
    //
    // An idle timeout can be implemented by repeatedly extending
    // the deadline after successful Read or Write calls.
    //
    // A zero value for t means I/O operations will not time out.
    SetDeadline(t time.Time) error

    // SetReadDeadline sets the deadline for future Read calls.
    // A zero value for t means Read will not time out.
    SetReadDeadline(t time.Time) error

    // SetWriteDeadline sets the deadline for future Write calls.
    // Even if write times out, it may return n &gt; 0, indicating that
    // some of the data was successfully written.
    // A zero value for t means Write will not time out.
    SetWriteDeadline(t time.Time) error
}</pre>
		<p>Conn is a generic stream-oriented network connection.

Multiple goroutines may invoke methods on a Conn simultaneously.
</p>
		
			<h4 id="Dial">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dial.go?name=release#91">Dial</a></h4>
			<pre>func Dial(net, addr string) (Conn, error)</pre>
			<p>Dial connects to the address addr on the network net.

Known networks are &#34;tcp&#34;, &#34;tcp4&#34; (IPv4-only), &#34;tcp6&#34; (IPv6-only),
&#34;udp&#34;, &#34;udp4&#34; (IPv4-only), &#34;udp6&#34; (IPv6-only), &#34;ip&#34;, &#34;ip4&#34;
(IPv4-only), &#34;ip6&#34; (IPv6-only), &#34;unix&#34; and &#34;unixpacket&#34;.

For TCP and UDP networks, addresses have the form host:port.
If host is a literal IPv6 address, it must be enclosed
in square brackets.  The functions JoinHostPort and SplitHostPort
manipulate addresses in this form.

Examples:
	Dial(&#34;tcp&#34;, &#34;12.34.56.78:80&#34;)
	Dial(&#34;tcp&#34;, &#34;google.com:80&#34;)
	Dial(&#34;tcp&#34;, &#34;[de:ad:be:ef::ca:fe]:80&#34;)

For IP networks, addr must be &#34;ip&#34;, &#34;ip4&#34; or &#34;ip6&#34; followed
by a colon and a protocol number or name.

Examples:
	Dial(&#34;ip4:1&#34;, &#34;127.0.0.1&#34;)
	Dial(&#34;ip6:ospf&#34;, &#34;::1&#34;)
</p>
		
			<h4 id="DialTimeout">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dial.go?name=release#120">DialTimeout</a></h4>
			<pre>func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)</pre>
			<p>DialTimeout acts like Dial but takes a timeout.
The timeout includes name resolution, if required.
</p>
		
			<h4 id="FileConn">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/file.go?name=release#77">FileConn</a></h4>
			<pre>func FileConn(f *os.File) (c Conn, err error)</pre>
			<p>FileConn returns a copy of the network connection corresponding to
the open file f.  It is the caller&#39;s responsibility to close f when
finished.  Closing c does not affect f, and closing f does not
affect c.
</p>
		
			<h4 id="Pipe">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/pipe.go?name=release#18">Pipe</a></h4>
			<pre>func Pipe() (Conn, Conn)</pre>
			<p>Pipe creates a synchronous, in-memory, full duplex
network connection; both ends implement the Conn interface.
Reads on one end are matched with writes on the other,
copying data directly between the two; there is no internal
buffering.
</p>
		
		
	
		<h3 id="DNSConfigError">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#255">DNSConfigError</a></h3>
		<pre class="pre-x-scrollable">type DNSConfigError struct {
    Err error
}</pre>
		<p>DNSConfigError represents an error reading the machine&#39;s DNS configuration.
</p>
		
		
			<h4 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#259">Error</a></h4>
			<pre>func (e *DNSConfigError) Error() string</pre>
			<p></p>
		
			<h4 id="Temporary">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#264">Temporary</a></h4>
			<pre>func (e *DNSConfigError) Temporary() bool</pre>
			<p></p>
		
			<h4 id="Timeout">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#263">Timeout</a></h4>
			<pre>func (e *DNSConfigError) Timeout() bool</pre>
			<p></p>
		
	
		<h3 id="DNSError">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsclient.go?name=release#13">DNSError</a></h3>
		<pre class="pre-x-scrollable">type DNSError struct {
    Err       string // description of the error
    Name      string // name looked for
    Server    string // server used
    IsTimeout bool
}</pre>
		<p>DNSError represents a DNS lookup error.
</p>
		
		
			<h4 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsclient.go?name=release#20">Error</a></h4>
			<pre>func (e *DNSError) Error() string</pre>
			<p></p>
		
			<h4 id="Temporary">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsclient.go?name=release#33">Temporary</a></h4>
			<pre>func (e *DNSError) Temporary() bool</pre>
			<p></p>
		
			<h4 id="Timeout">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsclient.go?name=release#32">Timeout</a></h4>
			<pre>func (e *DNSError) Timeout() bool</pre>
			<p></p>
		
	
		<h3 id="Error">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#107">Error</a></h3>
		<pre class="pre-x-scrollable">type Error interface {
    error
    Timeout() bool   // Is the error a timeout?
    Temporary() bool // Is the error temporary?
}</pre>
		<p>An Error represents a network error.
</p>
		
		
	
		<h3 id="Flags">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#30">Flags</a></h3>
		<pre class="pre-x-scrollable">type Flags uint</pre>
		<p></p>
		
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#48">String</a></h4>
			<pre>func (f Flags) String() string</pre>
			<p></p>
		
	
		<h3 id="HardwareAddr">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/mac.go?name=release#14">HardwareAddr</a></h3>
		<pre class="pre-x-scrollable">type HardwareAddr []byte</pre>
		<p>A HardwareAddr represents a physical hardware address.
</p>
		
			<h4 id="ParseMAC">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/mac.go?name=release#39">ParseMAC</a></h4>
			<pre>func ParseMAC(s string) (hw HardwareAddr, err error)</pre>
			<p>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, or EUI-64 using one of the
following formats:
  01:23:45:67:89:ab
  01:23:45:67:89:ab:cd:ef
  01-23-45-67-89-ab
  01-23-45-67-89-ab-cd-ef
  0123.4567.89ab
  0123.4567.89ab.cdef
</p>
		
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/mac.go?name=release#16">String</a></h4>
			<pre>func (a HardwareAddr) String() string</pre>
			<p></p>
		
	
		<h3 id="IP">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#30">IP</a></h3>
		<pre class="pre-x-scrollable">type IP []byte</pre>
		<p>An IP is a single IP address, an array of bytes.
Functions in this package accept either 4-byte (IPv4)
or 16-byte (IPv6) arrays as input.

Note that in this documentation, referring to an
IP address as an IPv4 address or an IPv6 address
is a semantic property of the address, not just the
length of the byte array: a 16-byte array can still
be an IPv4 address.
</p>
		
			<h4 id="IPv4">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#43">IPv4</a></h4>
			<pre>func IPv4(a, b, c, d byte) IP</pre>
			<p>IPv4 returns the IP address (in 16-byte form) of the
IPv4 address a.b.c.d.
</p>
		
			<h4 id="ParseCIDR">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#631">ParseCIDR</a></h4>
			<pre>func ParseCIDR(s string) (IP, *IPNet, error)</pre>
			<p>ParseCIDR parses s as a CIDR notation IP address and mask,
like &#34;192.168.100.1/24&#34; or &#34;2001:DB8::/48&#34;, as defined in
RFC 4632 and RFC 4291.

It returns the IP address and the network implied by the IP
and mask.  For example, ParseCIDR(&#34;192.168.100.1/16&#34;) returns
the IP address 192.168.100.1 and the network 192.168.0.0/16.
</p>
		
			<h4 id="ParseIP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#617">ParseIP</a></h4>
			<pre>func ParseIP(s string) IP</pre>
			<p>ParseIP parses s as an IP address, returning the result.
The string s can be in dotted decimal (&#34;74.125.19.99&#34;)
or IPv6 (&#34;2001:4860:0:2001::68&#34;) form.
If s is not a valid textual representation of an IP address,
ParseIP returns nil.
</p>
		
		
			<h4 id="DefaultMask">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#213">DefaultMask</a></h4>
			<pre>func (ip IP) DefaultMask() IPMask</pre>
			<p>DefaultMask returns the default IP mask for the IP address ip.
Only IPv4 addresses have default masks; DefaultMask returns
nil if ip is not a valid IPv4 address.
</p>
		
			<h4 id="Equal">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#317">Equal</a></h4>
			<pre>func (ip IP) Equal(x IP) bool</pre>
			<p>Equal returns true if ip and x are the same IP address.
An IPv4 address and that same address in IPv6 form are
considered to be equal.
</p>
		
			<h4 id="IsGlobalUnicast">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#159">IsGlobalUnicast</a></h4>
			<pre>func (ip IP) IsGlobalUnicast() bool</pre>
			<p>IsGlobalUnicast returns true if ip is a global unicast
address.
</p>
		
			<h4 id="IsInterfaceLocalMulticast">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#135">IsInterfaceLocalMulticast</a></h4>
			<pre>func (ip IP) IsInterfaceLocalMulticast() bool</pre>
			<p>IsInterfaceLinkLocalMulticast returns true if ip is
an interface-local multicast address.
</p>
		
			<h4 id="IsLinkLocalMulticast">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#141">IsLinkLocalMulticast</a></h4>
			<pre>func (ip IP) IsLinkLocalMulticast() bool</pre>
			<p>IsLinkLocalMulticast returns true if ip is a link-local
multicast address.
</p>
		
			<h4 id="IsLinkLocalUnicast">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#150">IsLinkLocalUnicast</a></h4>
			<pre>func (ip IP) IsLinkLocalUnicast() bool</pre>
			<p>IsLinkLocalUnicast returns true if ip is a link-local
unicast address.
</p>
		
			<h4 id="IsLoopback">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#118">IsLoopback</a></h4>
			<pre>func (ip IP) IsLoopback() bool</pre>
			<p>IsLoopback returns true if ip is a loopback address.
</p>
		
			<h4 id="IsMulticast">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#126">IsMulticast</a></h4>
			<pre>func (ip IP) IsMulticast() bool</pre>
			<p>IsMulticast returns true if ip is a multicast address.
</p>
		
			<h4 id="IsUnspecified">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#110">IsUnspecified</a></h4>
			<pre>func (ip IP) IsUnspecified() bool</pre>
			<p>IsUnspecified returns true if ip is an unspecified address.
</p>
		
			<h4 id="Mask">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#238">Mask</a></h4>
			<pre>func (ip IP) Mask(mask IPMask) IP</pre>
			<p>Mask returns the result of masking the IP address ip with mask.
</p>
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#260">String</a></h4>
			<pre>func (ip IP) String() string</pre>
			<p>String returns the string form of the IP address ip.
If the address is an IPv4 address, the string representation
is dotted decimal (&#34;74.125.19.99&#34;).  Otherwise the representation
is IPv6 (&#34;2001:4860:0:2001::68&#34;).
</p>
		
			<h4 id="To16">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#193">To16</a></h4>
			<pre>func (ip IP) To16() IP</pre>
			<p>To16 converts the IP address ip to a 16-byte representation.
If ip is not an IP address (it is the wrong length), To16 returns nil.
</p>
		
			<h4 id="To4">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#178">To4</a></h4>
			<pre>func (ip IP) To4() IP</pre>
			<p>To4 converts the IPv4 address ip to a 4-byte representation.
If ip is not an IPv4 address, To4 returns nil.
</p>
		
	
		<h3 id="IPAddr">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock.go?name=release#10">IPAddr</a></h3>
		<pre class="pre-x-scrollable">type IPAddr struct {
    IP IP
}</pre>
		<p>IPAddr represents the address of an IP end point.
</p>
		
			<h4 id="ResolveIPAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock.go?name=release#28">ResolveIPAddr</a></h4>
			<pre>func ResolveIPAddr(net, addr string) (*IPAddr, error)</pre>
			<p>ResolveIPAddr parses addr as an IP address and resolves domain
names to numeric addresses on the network net, which must be
&#34;ip&#34;, &#34;ip4&#34; or &#34;ip6&#34;.  A literal IPv6 host address must be
enclosed in square brackets, as in &#34;[::]&#34;.
</p>
		
		
			<h4 id="Network">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock.go?name=release#15">Network</a></h4>
			<pre>func (a *IPAddr) Network() string</pre>
			<p>Network returns the address&#39;s network name, &#34;ip&#34;.
</p>
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock.go?name=release#17">String</a></h4>
			<pre>func (a *IPAddr) String() string</pre>
			<p></p>
		
	
		<h3 id="IPConn">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#57">IPConn</a></h3>
		<pre class="pre-x-scrollable">type IPConn struct {
    // contains filtered or unexported fields
}</pre>
		<p>IPConn is the implementation of the Conn and PacketConn
interfaces for IP network connections.
</p>
		
			<h4 id="DialIP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#218">DialIP</a></h4>
			<pre>func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</pre>
			<p>DialIP connects to the remote address raddr on the network protocol netProto,
which must be &#34;ip&#34;, &#34;ip4&#34;, or &#34;ip6&#34; followed by a colon and a protocol number or name.
</p>
		
			<h4 id="ListenIP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#242">ListenIP</a></h4>
			<pre>func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</pre>
			<p>ListenIP listens for incoming IP packets addressed to the
local address laddr.  The returned connection c&#39;s ReadFrom
and WriteTo methods can be used to receive and send IP
packets with per-packet addressing.
</p>
		
		
			<h4 id="Close">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#82">Close</a></h4>
			<pre>func (c *IPConn) Close() error</pre>
			<p>Close closes the IP connection.
</p>
		
			<h4 id="File">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#262">File</a></h4>
			<pre>func (c *IPConn) File() (f *os.File, err error)</pre>
			<p>File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>
		
			<h4 id="LocalAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#90">LocalAddr</a></h4>
			<pre>func (c *IPConn) LocalAddr() Addr</pre>
			<p>LocalAddr returns the local network address.
</p>
		
			<h4 id="Read">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#68">Read</a></h4>
			<pre>func (c *IPConn) Read(b []byte) (int, error)</pre>
			<p>Read implements the Conn Read method.
</p>
		
			<h4 id="ReadFrom">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#179">ReadFrom</a></h4>
			<pre>func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</pre>
			<p>ReadFrom implements the PacketConn ReadFrom method.
</p>
		
			<h4 id="ReadFromIP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#156">ReadFromIP</a></h4>
			<pre>func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</pre>
			<p>ReadFromIP reads an IP packet from c, copying the payload into b.
It returns the number of bytes copied into b and the return address
that was on the packet.

ReadFromIP can be made to time out and return an error with
Timeout() == true after a fixed time limit; see SetDeadline and
SetReadDeadline.
</p>
		
			<h4 id="RemoteAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#98">RemoteAddr</a></h4>
			<pre>func (c *IPConn) RemoteAddr() Addr</pre>
			<p>RemoteAddr returns the remote network address, a *IPAddr.
</p>
		
			<h4 id="SetDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#106">SetDeadline</a></h4>
			<pre>func (c *IPConn) SetDeadline(t time.Time) error</pre>
			<p>SetDeadline implements the Conn SetDeadline method.
</p>
		
			<h4 id="SetReadBuffer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#131">SetReadBuffer</a></h4>
			<pre>func (c *IPConn) SetReadBuffer(bytes int) error</pre>
			<p>SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>
		
			<h4 id="SetReadDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#114">SetReadDeadline</a></h4>
			<pre>func (c *IPConn) SetReadDeadline(t time.Time) error</pre>
			<p>SetReadDeadline implements the Conn SetReadDeadline method.
</p>
		
			<h4 id="SetWriteBuffer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#140">SetWriteBuffer</a></h4>
			<pre>func (c *IPConn) SetWriteBuffer(bytes int) error</pre>
			<p>SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>
		
			<h4 id="SetWriteDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#122">SetWriteDeadline</a></h4>
			<pre>func (c *IPConn) SetWriteDeadline(t time.Time) error</pre>
			<p>SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>
		
			<h4 id="Write">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#74">Write</a></h4>
			<pre>func (c *IPConn) Write(b []byte) (int, error)</pre>
			<p>Write implements the Conn Write method.
</p>
		
			<h4 id="WriteTo">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#205">WriteTo</a></h4>
			<pre>func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</pre>
			<p>WriteTo implements the PacketConn WriteTo method.
</p>
		
			<h4 id="WriteToIP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release#193">WriteToIP</a></h4>
			<pre>func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</pre>
			<p>WriteToIP writes an IP packet to addr via c, copying the payload from b.

WriteToIP can be made to time out and return
an error with Timeout() == true after a fixed time limit;
see SetDeadline and SetWriteDeadline.
On packet-oriented connections, write timeouts are rare.
</p>
		
	
		<h3 id="IPMask">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#33">IPMask</a></h3>
		<pre class="pre-x-scrollable">type IPMask []byte</pre>
		<p>An IP mask is an IP address.
</p>
		
			<h4 id="CIDRMask">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#69">CIDRMask</a></h4>
			<pre>func CIDRMask(ones, bits int) IPMask</pre>
			<p>CIDRMask returns an IPMask consisting of `ones&#39; 1 bits
followed by 0s up to a total length of `bits&#39; bits.
For a mask of this form, CIDRMask is the inverse of IPMask.Size.
</p>
		
			<h4 id="IPv4Mask">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#57">IPv4Mask</a></h4>
			<pre>func IPv4Mask(a, b, c, d byte) IPMask</pre>
			<p>IPv4Mask returns the IP mask (in 4-byte form) of the
IPv4 mask a.b.c.d.
</p>
		
		
			<h4 id="Size">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#374">Size</a></h4>
			<pre>func (m IPMask) Size() (ones, bits int)</pre>
			<p>Size returns the number of leading ones and total bits in the mask.
If the mask is not in the canonical form--ones followed by zeros--then
Size returns 0, 0.
</p>
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#383">String</a></h4>
			<pre>func (m IPMask) String() string</pre>
			<p>String returns the hexadecimal form of m, with no punctuation.
</p>
		
	
		<h3 id="IPNet">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#36">IPNet</a></h3>
		<pre class="pre-x-scrollable">type IPNet struct {
    IP   IP     // network number
    Mask IPMask // network mask
}</pre>
		<p>An IPNet represents an IP network.
</p>
		
		
			<h4 id="Contains">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#418">Contains</a></h4>
			<pre>func (n *IPNet) Contains(ip IP) bool</pre>
			<p>Contains reports whether the network includes ip.
</p>
		
			<h4 id="Network">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#454">Network</a></h4>
			<pre>func (n *IPNet) Network() string</pre>
			<p>Network returns the address&#39;s network name, &#34;ip&#43;net&#34;.
</p>
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#441">String</a></h4>
			<pre>func (n *IPNet) String() string</pre>
			<p>String returns the CIDR notation of n like &#34;192.168.100.1/24&#34;
or &#34;2001:DB8::/48&#34; as defined in RFC 4632 and RFC 4291.
If the mask is not in the canonical form, it returns the
string which consists of an IP address, followed by a slash
character and a mask expressed as hexadecimal form with no
punctuation like &#34;192.168.100.1/c000ff00&#34;.
</p>
		
	
		<h3 id="Interface">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#22">Interface</a></h3>
		<pre class="pre-x-scrollable">type Interface struct {
    Index        int          // positive integer that starts at one, zero is never used
    MTU          int          // maximum transmission unit
    Name         string       // e.g., &#34;en0&#34;, &#34;lo0&#34;, &#34;eth0.100&#34;
    HardwareAddr HardwareAddr // IEEE MAC-48, EUI-48 and EUI-64 form
    Flags        Flags        // e.g., FlagUp, FlagLoopback, FlagMulticast
}</pre>
		<p>Interface represents a mapping between network interface name
and index.  It also represents network interface facility
information.
</p>
		
			<h4 id="InterfaceByIndex">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#93">InterfaceByIndex</a></h4>
			<pre>func InterfaceByIndex(index int) (*Interface, error)</pre>
			<p>InterfaceByIndex returns the interface specified by index.
</p>
		
			<h4 id="InterfaceByName">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#108">InterfaceByName</a></h4>
			<pre>func InterfaceByName(name string) (*Interface, error)</pre>
			<p>InterfaceByName returns the interface specified by name.
</p>
		
		
			<h4 id="Addrs">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#65">Addrs</a></h4>
			<pre>func (ifi *Interface) Addrs() ([]Addr, error)</pre>
			<p>Addrs returns interface addresses for a specific interface.
</p>
		
			<h4 id="MulticastAddrs">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release#74">MulticastAddrs</a></h4>
			<pre>func (ifi *Interface) MulticastAddrs() ([]Addr, error)</pre>
			<p>MulticastAddrs returns multicast, joined group addresses for
a specific interface.
</p>
		
	
		<h3 id="InvalidAddrError">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ipsock.go?name=release#58">InvalidAddrError</a></h3>
		<pre class="pre-x-scrollable">type InvalidAddrError string</pre>
		<p></p>
		
		
			<h4 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ipsock.go?name=release#60">Error</a></h4>
			<pre>func (e InvalidAddrError) Error() string</pre>
			<p></p>
		
			<h4 id="Temporary">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ipsock.go?name=release#62">Temporary</a></h4>
			<pre>func (e InvalidAddrError) Temporary() bool</pre>
			<p></p>
		
			<h4 id="Timeout">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ipsock.go?name=release#61">Timeout</a></h4>
			<pre>func (e InvalidAddrError) Timeout() bool</pre>
			<p></p>
		
	
		<h3 id="Listener">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#162">Listener</a></h3>
		<pre class="pre-x-scrollable">type Listener interface {
    // Accept waits for and returns the next connection to the listener.
    Accept() (c Conn, err error)

    // Close closes the listener.
    // Any blocked Accept operations will be unblocked and return errors.
    Close() error

    // Addr returns the listener&#39;s network address.
    Addr() Addr
}</pre>
		<p>A Listener is a generic network listener for stream-oriented protocols.

Multiple goroutines may invoke methods on a Listener simultaneously.
</p>
		
			<h4 id="FileListener">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/file.go?name=release#100">FileListener</a></h4>
			<pre>func FileListener(f *os.File) (l Listener, err error)</pre>
			<p>FileListener returns a copy of the network listener corresponding
to the open file f.  It is the caller&#39;s responsibility to close l
when finished.  Closing l does not affect f, and closing f does not
affect l.
</p>
		
			<h4 id="Listen">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dial.go?name=release#177">Listen</a></h4>
			<pre>func Listen(net, laddr string) (Listener, error)</pre>
			<p>Listen announces on the local network address laddr.
The network string net must be a stream-oriented network:
&#34;tcp&#34;, &#34;tcp4&#34;, &#34;tcp6&#34;, &#34;unix&#34; or &#34;unixpacket&#34;.
</p>
		
		
	
		<h3 id="MX">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsclient.go?name=release#225">MX</a></h3>
		<pre class="pre-x-scrollable">type MX struct {
    Host string
    Pref uint16
}</pre>
		<p>An MX represents a single DNS MX record.
</p>
		
		
	
		<h3 id="OpError">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#176">OpError</a></h3>
		<pre class="pre-x-scrollable">type OpError struct {
    Op   string
    Net  string
    Addr Addr
    Err  error
}</pre>
		<p></p>
		
		
			<h4 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#183">Error</a></h4>
			<pre>func (e *OpError) Error() string</pre>
			<p></p>
		
			<h4 id="Temporary">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#202">Temporary</a></h4>
			<pre>func (e *OpError) Temporary() bool</pre>
			<p></p>
		
			<h4 id="Timeout">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#211">Timeout</a></h4>
			<pre>func (e *OpError) Timeout() bool</pre>
			<p></p>
		
	
		<h3 id="PacketConn">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#116">PacketConn</a></h3>
		<pre class="pre-x-scrollable">type PacketConn interface {
    // ReadFrom reads a packet from the connection,
    // copying the payload into b.  It returns the number of
    // bytes copied into b and the return address that
    // was on the packet.
    // ReadFrom can be made to time out and return
    // an error with Timeout() == true after a fixed time limit;
    // see SetDeadline and SetReadDeadline.
    ReadFrom(b []byte) (n int, addr Addr, err error)

    // WriteTo writes a packet with payload b to addr.
    // WriteTo can be made to time out and return
    // an error with Timeout() == true after a fixed time limit;
    // see SetDeadline and SetWriteDeadline.
    // On packet-oriented connections, write timeouts are rare.
    WriteTo(b []byte, addr Addr) (n int, err error)

    // Close closes the connection.
    // Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.
    Close() error

    // LocalAddr returns the local network address.
    LocalAddr() Addr

    // SetDeadline sets the read and write deadlines associated
    // with the connection.
    SetDeadline(t time.Time) error

    // SetReadDeadline sets the deadline for future Read calls.
    // If the deadline is reached, Read will fail with a timeout
    // (see type Error) instead of blocking.
    // A zero value for t means Read will not time out.
    SetReadDeadline(t time.Time) error

    // SetWriteDeadline sets the deadline for future Write calls.
    // If the deadline is reached, Write will fail with a timeout
    // (see type Error) instead of blocking.
    // A zero value for t means Write will not time out.
    // Even if write times out, it may return n &gt; 0, indicating that
    // some of the data was successfully written.
    SetWriteDeadline(t time.Time) error
}</pre>
		<p>PacketConn is a generic packet-oriented network connection.

Multiple goroutines may invoke methods on a PacketConn simultaneously.
</p>
		
			<h4 id="FilePacketConn">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/file.go?name=release#119">FilePacketConn</a></h4>
			<pre>func FilePacketConn(f *os.File) (c PacketConn, err error)</pre>
			<p>FilePacketConn returns a copy of the packet network connection
corresponding to the open file f.  It is the caller&#39;s
responsibility to close f when finished.  Closing c does not affect
f, and closing f does not affect c.
</p>
		
			<h4 id="ListenPacket">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dial.go?name=release#202">ListenPacket</a></h4>
			<pre>func ListenPacket(net, addr string) (PacketConn, error)</pre>
			<p>ListenPacket announces on the local network address laddr.
The network string net must be a packet-oriented network:
&#34;udp&#34;, &#34;udp4&#34;, &#34;udp6&#34;, &#34;ip&#34;, &#34;ip4&#34;, &#34;ip6&#34; or &#34;unixgram&#34;.
</p>
		
		
	
		<h3 id="ParseError">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#593">ParseError</a></h3>
		<pre class="pre-x-scrollable">type ParseError struct {
    Type string
    Text string
}</pre>
		<p>A ParseError represents a malformed text string and the type of string that was expected.
</p>
		
		
			<h4 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release#598">Error</a></h4>
			<pre>func (e *ParseError) Error() string</pre>
			<p></p>
		
	
		<h3 id="SRV">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsclient.go?name=release#166">SRV</a></h3>
		<pre class="pre-x-scrollable">type SRV struct {
    Target   string
    Port     uint16
    Priority uint16
    Weight   uint16
}</pre>
		<p>An SRV represents a single DNS SRV record.
</p>
		
		
	
		<h3 id="TCPAddr">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock.go?name=release#10">TCPAddr</a></h3>
		<pre class="pre-x-scrollable">type TCPAddr struct {
    IP   IP
    Port int
}</pre>
		<p>TCPAddr represents the address of a TCP end point.
</p>
		
			<h4 id="ResolveTCPAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock.go?name=release#30">ResolveTCPAddr</a></h4>
			<pre>func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</pre>
			<p>ResolveTCPAddr parses addr as a TCP address of the form
host:port and resolves domain names or port names to
numeric addresses on the network net, which must be &#34;tcp&#34;,
&#34;tcp4&#34; or &#34;tcp6&#34;.  A literal IPv6 host address must be
enclosed in square brackets, as in &#34;[::]:80&#34;.
</p>
		
		
			<h4 id="Network">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock.go?name=release#16">Network</a></h4>
			<pre>func (a *TCPAddr) Network() string</pre>
			<p>Network returns the address&#39;s network name, &#34;tcp&#34;.
</p>
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock.go?name=release#18">String</a></h4>
			<pre>func (a *TCPAddr) String() string</pre>
			<p></p>
		
	
		<h3 id="TCPConn">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#68">TCPConn</a></h3>
		<pre class="pre-x-scrollable">type TCPConn struct {
    // contains filtered or unexported fields
}</pre>
		<p>TCPConn is an implementation of the Conn interface
for TCP network connections.
</p>
		
			<h4 id="DialTCP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#236">DialTCP</a></h4>
			<pre>func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</pre>
			<p>DialTCP connects to the remote address raddr on the network net,
which must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.  If laddr is not nil, it is used
as the local address for the connection.
</p>
		
		
			<h4 id="Close">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#107">Close</a></h4>
			<pre>func (c *TCPConn) Close() error</pre>
			<p>Close closes the TCP connection.
</p>
		
			<h4 id="CloseRead">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#116">CloseRead</a></h4>
			<pre>func (c *TCPConn) CloseRead() error</pre>
			<p>CloseRead shuts down the reading side of the TCP connection.
Most callers should just use Close.
</p>
		
			<h4 id="CloseWrite">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#125">CloseWrite</a></h4>
			<pre>func (c *TCPConn) CloseWrite() error</pre>
			<p>CloseWrite shuts down the writing side of the TCP connection.
Most callers should just use Close.
</p>
		
			<h4 id="File">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#231">File</a></h4>
			<pre>func (c *TCPConn) File() (f *os.File, err error)</pre>
			<p>File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>
		
			<h4 id="LocalAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#133">LocalAddr</a></h4>
			<pre>func (c *TCPConn) LocalAddr() Addr</pre>
			<p>LocalAddr returns the local network address, a *TCPAddr.
</p>
		
			<h4 id="Read">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#83">Read</a></h4>
			<pre>func (c *TCPConn) Read(b []byte) (n int, err error)</pre>
			<p>Read implements the Conn Read method.
</p>
		
			<h4 id="ReadFrom">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#91">ReadFrom</a></h4>
			<pre>func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</pre>
			<p>ReadFrom implements the io.ReaderFrom ReadFrom method.
</p>
		
			<h4 id="RemoteAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#141">RemoteAddr</a></h4>
			<pre>func (c *TCPConn) RemoteAddr() Addr</pre>
			<p>RemoteAddr returns the remote network address, a *TCPAddr.
</p>
		
			<h4 id="SetDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#149">SetDeadline</a></h4>
			<pre>func (c *TCPConn) SetDeadline(t time.Time) error</pre>
			<p>SetDeadline implements the Conn SetDeadline method.
</p>
		
			<h4 id="SetKeepAlive">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#210">SetKeepAlive</a></h4>
			<pre>func (c *TCPConn) SetKeepAlive(keepalive bool) error</pre>
			<p>SetKeepAlive sets whether the operating system should send
keepalive messages on the connection.
</p>
		
			<h4 id="SetLinger">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#201">SetLinger</a></h4>
			<pre>func (c *TCPConn) SetLinger(sec int) error</pre>
			<p>SetLinger sets the behavior of Close() on a connection
which still has data waiting to be sent or to be acknowledged.

If sec &lt; 0 (the default), Close returns immediately and
the operating system finishes sending the data in the background.

If sec == 0, Close returns immediately and the operating system
discards any unsent or unacknowledged data.

If sec &gt; 0, Close blocks for at most sec seconds waiting for
data to be sent and acknowledged.
</p>
		
			<h4 id="SetNoDelay">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#221">SetNoDelay</a></h4>
			<pre>func (c *TCPConn) SetNoDelay(noDelay bool) error</pre>
			<p>SetNoDelay controls whether the operating system should delay
packet transmission in hopes of sending fewer packets
(Nagle&#39;s algorithm).  The default is true (no delay), meaning
that data is sent as soon as possible after a Write.
</p>
		
			<h4 id="SetReadBuffer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#174">SetReadBuffer</a></h4>
			<pre>func (c *TCPConn) SetReadBuffer(bytes int) error</pre>
			<p>SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>
		
			<h4 id="SetReadDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#157">SetReadDeadline</a></h4>
			<pre>func (c *TCPConn) SetReadDeadline(t time.Time) error</pre>
			<p>SetReadDeadline implements the Conn SetReadDeadline method.
</p>
		
			<h4 id="SetWriteBuffer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#183">SetWriteBuffer</a></h4>
			<pre>func (c *TCPConn) SetWriteBuffer(bytes int) error</pre>
			<p>SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>
		
			<h4 id="SetWriteDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#165">SetWriteDeadline</a></h4>
			<pre>func (c *TCPConn) SetWriteDeadline(t time.Time) error</pre>
			<p>SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>
		
			<h4 id="Write">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#99">Write</a></h4>
			<pre>func (c *TCPConn) Write(b []byte) (n int, err error)</pre>
			<p>Write implements the Conn Write method.
</p>
		
	
		<h3 id="TCPListener">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#291">TCPListener</a></h3>
		<pre class="pre-x-scrollable">type TCPListener struct {
    // contains filtered or unexported fields
}</pre>
		<p>TCPListener is a TCP network listener.
Clients should typically use variables of type Listener
instead of assuming TCP.
</p>
		
			<h4 id="ListenTCP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#299">ListenTCP</a></h4>
			<pre>func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</pre>
			<p>ListenTCP announces on the TCP address laddr and returns a TCP listener.
Net must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.
If laddr has a port of 0, it means to listen on some available port.
The caller can use l.Addr() to retrieve the chosen address.
</p>
		
		
			<h4 id="Accept">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#329">Accept</a></h4>
			<pre>func (l *TCPListener) Accept() (c Conn, err error)</pre>
			<p>Accept implements the Accept method in the Listener interface;
it waits for the next call and returns a generic Conn.
</p>
		
			<h4 id="AcceptTCP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#316">AcceptTCP</a></h4>
			<pre>func (l *TCPListener) AcceptTCP() (c *TCPConn, err error)</pre>
			<p>AcceptTCP accepts the next incoming call and returns the new connection
and the remote address.
</p>
		
			<h4 id="Addr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#347">Addr</a></h4>
			<pre>func (l *TCPListener) Addr() Addr</pre>
			<p>Addr returns the listener&#39;s network address, a *TCPAddr.
</p>
		
			<h4 id="Close">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#339">Close</a></h4>
			<pre>func (l *TCPListener) Close() error</pre>
			<p>Close stops listening on the TCP address.
Already Accepted connections are not closed.
</p>
		
			<h4 id="File">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#361">File</a></h4>
			<pre>func (l *TCPListener) File() (f *os.File, err error)</pre>
			<p>File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
</p>
		
			<h4 id="SetDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release#351">SetDeadline</a></h4>
			<pre>func (l *TCPListener) SetDeadline(t time.Time) error</pre>
			<p>SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.
</p>
		
	
		<h3 id="UDPAddr">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock.go?name=release#10">UDPAddr</a></h3>
		<pre class="pre-x-scrollable">type UDPAddr struct {
    IP   IP
    Port int
}</pre>
		<p>UDPAddr represents the address of a UDP end point.
</p>
		
			<h4 id="ResolveUDPAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock.go?name=release#30">ResolveUDPAddr</a></h4>
			<pre>func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</pre>
			<p>ResolveUDPAddr parses addr as a UDP address of the form
host:port and resolves domain names or port names to
numeric addresses on the network net, which must be &#34;udp&#34;,
&#34;udp4&#34; or &#34;udp6&#34;.  A literal IPv6 host address must be
enclosed in square brackets, as in &#34;[::]:80&#34;.
</p>
		
		
			<h4 id="Network">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock.go?name=release#16">Network</a></h4>
			<pre>func (a *UDPAddr) Network() string</pre>
			<p>Network returns the address&#39;s network name, &#34;udp&#34;.
</p>
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock.go?name=release#18">String</a></h4>
			<pre>func (a *UDPAddr) String() string</pre>
			<p></p>
		
	
		<h3 id="UDPConn">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#60">UDPConn</a></h3>
		<pre class="pre-x-scrollable">type UDPConn struct {
    // contains filtered or unexported fields
}</pre>
		<p>UDPConn is the implementation of the Conn and PacketConn
interfaces for UDP network connections.
</p>
		
			<h4 id="DialUDP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#223">DialUDP</a></h4>
			<pre>func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</pre>
			<p>DialUDP connects to the remote address raddr on the network net,
which must be &#34;udp&#34;, &#34;udp4&#34;, or &#34;udp6&#34;.  If laddr is not nil, it is used
as the local address for the connection.
</p>
		
			<h4 id="ListenMulticastUDP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#263">ListenMulticastUDP</a></h4>
			<pre>func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</pre>
			<p>ListenMulticastUDP listens for incoming multicast UDP packets
addressed to the group address gaddr on ifi, which specifies
the interface to join.  ListenMulticastUDP uses default
multicast interface if ifi is nil.
</p>
		
			<h4 id="ListenUDP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#243">ListenUDP</a></h4>
			<pre>func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</pre>
			<p>ListenUDP listens for incoming UDP packets addressed to the
local address laddr.  The returned connection c&#39;s ReadFrom
and WriteTo methods can be used to receive and send UDP
packets with per-packet addressing.
</p>
		
			<h4 id="ListenUnixgram">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#414">ListenUnixgram</a></h4>
			<pre>func ListenUnixgram(net string, laddr *UnixAddr) (*UDPConn, error)</pre>
			<p>ListenUnixgram listens for incoming Unix datagram packets addressed to the
local address laddr.  The returned connection c&#39;s ReadFrom
and WriteTo methods can be used to receive and send UDP
packets with per-packet addressing.  The network net must be &#34;unixgram&#34;.
</p>
		
		
			<h4 id="Close">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#87">Close</a></h4>
			<pre>func (c *UDPConn) Close() error</pre>
			<p>Close closes the UDP connection.
</p>
		
			<h4 id="File">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#218">File</a></h4>
			<pre>func (c *UDPConn) File() (f *os.File, err error)</pre>
			<p>File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>
		
			<h4 id="LocalAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#95">LocalAddr</a></h4>
			<pre>func (c *UDPConn) LocalAddr() Addr</pre>
			<p>LocalAddr returns the local network address.
</p>
		
			<h4 id="Read">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#71">Read</a></h4>
			<pre>func (c *UDPConn) Read(b []byte) (int, error)</pre>
			<p>Read implements the Conn Read method.
</p>
		
			<h4 id="ReadFrom">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#175">ReadFrom</a></h4>
			<pre>func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</pre>
			<p>ReadFrom implements the PacketConn ReadFrom method.
</p>
		
			<h4 id="ReadFromUDP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#160">ReadFromUDP</a></h4>
			<pre>func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</pre>
			<p>ReadFromUDP reads a UDP packet from c, copying the payload into b.
It returns the number of bytes copied into b and the return address
that was on the packet.

ReadFromUDP can be made to time out and return an error with Timeout() == true
after a fixed time limit; see SetDeadline and SetReadDeadline.
</p>
		
			<h4 id="RemoteAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#103">RemoteAddr</a></h4>
			<pre>func (c *UDPConn) RemoteAddr() Addr</pre>
			<p>RemoteAddr returns the remote network address, a *UDPAddr.
</p>
		
			<h4 id="SetDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#111">SetDeadline</a></h4>
			<pre>func (c *UDPConn) SetDeadline(t time.Time) error</pre>
			<p>SetDeadline implements the Conn SetDeadline method.
</p>
		
			<h4 id="SetReadBuffer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#136">SetReadBuffer</a></h4>
			<pre>func (c *UDPConn) SetReadBuffer(bytes int) error</pre>
			<p>SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>
		
			<h4 id="SetReadDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#119">SetReadDeadline</a></h4>
			<pre>func (c *UDPConn) SetReadDeadline(t time.Time) error</pre>
			<p>SetReadDeadline implements the Conn SetReadDeadline method.
</p>
		
			<h4 id="SetWriteBuffer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#145">SetWriteBuffer</a></h4>
			<pre>func (c *UDPConn) SetWriteBuffer(bytes int) error</pre>
			<p>SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>
		
			<h4 id="SetWriteDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#127">SetWriteDeadline</a></h4>
			<pre>func (c *UDPConn) SetWriteDeadline(t time.Time) error</pre>
			<p>SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>
		
			<h4 id="Write">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#79">Write</a></h4>
			<pre>func (c *UDPConn) Write(b []byte) (int, error)</pre>
			<p>Write implements the Conn Write method.
</p>
		
			<h4 id="WriteTo">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#204">WriteTo</a></h4>
			<pre>func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</pre>
			<p>WriteTo implements the PacketConn WriteTo method.
</p>
		
			<h4 id="WriteToUDP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release#189">WriteToUDP</a></h4>
			<pre>func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</pre>
			<p>WriteToUDP writes a UDP packet to addr via c, copying the payload from b.

WriteToUDP can be made to time out and return
an error with Timeout() == true after a fixed time limit;
see SetDeadline and SetWriteDeadline.
On packet-oriented connections, write timeouts are rare.
</p>
		
	
		<h3 id="UnixAddr">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock.go?name=release#10">UnixAddr</a></h3>
		<pre class="pre-x-scrollable">type UnixAddr struct {
    Name string
    Net  string
}</pre>
		<p>UnixAddr represents the address of a Unix domain socket end point.
</p>
		
			<h4 id="ResolveUnixAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock.go?name=release#37">ResolveUnixAddr</a></h4>
			<pre>func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</pre>
			<p>ResolveUnixAddr parses addr as a Unix domain socket address.
The string net gives the network name, &#34;unix&#34;, &#34;unixgram&#34; or
&#34;unixpacket&#34;.
</p>
		
		
			<h4 id="Network">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock.go?name=release#16">Network</a></h4>
			<pre>func (a *UnixAddr) Network() string</pre>
			<p>Network returns the address&#39;s network name, &#34;unix&#34; or &#34;unixgram&#34;.
</p>
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock.go?name=release#20">String</a></h4>
			<pre>func (a *UnixAddr) String() string</pre>
			<p></p>
		
	
		<h3 id="UnixConn">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#113">UnixConn</a></h3>
		<pre class="pre-x-scrollable">type UnixConn struct {
    // contains filtered or unexported fields
}</pre>
		<p>UnixConn is an implementation of the Conn interface
for connections to Unix domain sockets.
</p>
		
			<h4 id="DialUnix">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#307">DialUnix</a></h4>
			<pre>func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</pre>
			<p>DialUnix connects to the remote address raddr on the network net,
which must be &#34;unix&#34; or &#34;unixgram&#34;.  If laddr is not nil, it is used
as the local address for the connection.
</p>
		
		
			<h4 id="Close">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#140">Close</a></h4>
			<pre>func (c *UnixConn) Close() error</pre>
			<p>Close closes the Unix domain connection.
</p>
		
			<h4 id="File">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#302">File</a></h4>
			<pre>func (c *UnixConn) File() (f *os.File, err error)</pre>
			<p>File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>
		
			<h4 id="LocalAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#149">LocalAddr</a></h4>
			<pre>func (c *UnixConn) LocalAddr() Addr</pre>
			<p>LocalAddr returns the local network address, a *UnixAddr.
Unlike in other protocols, LocalAddr is usually nil for dialed connections.
</p>
		
			<h4 id="Read">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#124">Read</a></h4>
			<pre>func (c *UnixConn) Read(b []byte) (n int, err error)</pre>
			<p>Read implements the Conn Read method.
</p>
		
			<h4 id="ReadFrom">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#228">ReadFrom</a></h4>
			<pre>func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error)</pre>
			<p>ReadFrom implements the PacketConn ReadFrom method.
</p>
		
			<h4 id="ReadFromUnix">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#215">ReadFromUnix</a></h4>
			<pre>func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error)</pre>
			<p>ReadFromUnix reads a packet from c, copying the payload into b.
It returns the number of bytes copied into b and the source address
of the packet.

ReadFromUnix can be made to time out and return
an error with Timeout() == true after a fixed time limit;
see SetDeadline and SetReadDeadline.
</p>
		
			<h4 id="ReadMsgUnix">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#270">ReadMsgUnix</a></h4>
			<pre>func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</pre>
			<p>ReadMsgUnix reads a packet from c, copying the payload into b
and the associated out-of-band data into oob.
It returns the number of bytes copied into b, the number of
bytes copied into oob, the flags that were set on the packet,
and the source address of the packet.
</p>
		
			<h4 id="RemoteAddr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#159">RemoteAddr</a></h4>
			<pre>func (c *UnixConn) RemoteAddr() Addr</pre>
			<p>RemoteAddr returns the remote network address, a *UnixAddr.
Unlike in other protocols, RemoteAddr is usually nil for connections
accepted by a listener.
</p>
		
			<h4 id="SetDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#167">SetDeadline</a></h4>
			<pre>func (c *UnixConn) SetDeadline(t time.Time) error</pre>
			<p>SetDeadline implements the Conn SetDeadline method.
</p>
		
			<h4 id="SetReadBuffer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#192">SetReadBuffer</a></h4>
			<pre>func (c *UnixConn) SetReadBuffer(bytes int) error</pre>
			<p>SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>
		
			<h4 id="SetReadDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#175">SetReadDeadline</a></h4>
			<pre>func (c *UnixConn) SetReadDeadline(t time.Time) error</pre>
			<p>SetReadDeadline implements the Conn SetReadDeadline method.
</p>
		
			<h4 id="SetWriteBuffer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#201">SetWriteBuffer</a></h4>
			<pre>func (c *UnixConn) SetWriteBuffer(bytes int) error</pre>
			<p>SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>
		
			<h4 id="SetWriteDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#183">SetWriteDeadline</a></h4>
			<pre>func (c *UnixConn) SetWriteDeadline(t time.Time) error</pre>
			<p>SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>
		
			<h4 id="Write">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#132">Write</a></h4>
			<pre>func (c *UnixConn) Write(b []byte) (n int, err error)</pre>
			<p>Write implements the Conn Write method.
</p>
		
			<h4 id="WriteMsgUnix">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#285">WriteMsgUnix</a></h4>
			<pre>func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</pre>
			<p>WriteMsgUnix writes a packet to addr via c, copying the payload from b
and the associated out-of-band data from oob.  It returns the number
of payload and out-of-band bytes written.
</p>
		
			<h4 id="WriteTo">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#254">WriteTo</a></h4>
			<pre>func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error)</pre>
			<p>WriteTo implements the PacketConn WriteTo method.
</p>
		
			<h4 id="WriteToUnix">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#242">WriteToUnix</a></h4>
			<pre>func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error)</pre>
			<p>WriteToUnix writes a packet to addr via c, copying the payload from b.

WriteToUnix can be made to time out and return
an error with Timeout() == true after a fixed time limit;
see SetDeadline and SetWriteDeadline.
On packet-oriented connections, write timeouts are rare.
</p>
		
	
		<h3 id="UnixListener">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#318">UnixListener</a></h3>
		<pre class="pre-x-scrollable">type UnixListener struct {
    // contains filtered or unexported fields
}</pre>
		<p>UnixListener is a Unix domain socket listener.
Clients should typically use variables of type Listener
instead of assuming Unix domain sockets.
</p>
		
			<h4 id="ListenUnix">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#325">ListenUnix</a></h4>
			<pre>func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</pre>
			<p>ListenUnix announces on the Unix domain socket laddr and returns a Unix listener.
Net must be &#34;unix&#34; (stream sockets).
</p>
		
		
			<h4 id="Accept">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#360">Accept</a></h4>
			<pre>func (l *UnixListener) Accept() (c Conn, err error)</pre>
			<p>Accept implements the Accept method in the Listener interface;
it waits for the next call and returns a generic Conn.
</p>
		
			<h4 id="AcceptUnix">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#346">AcceptUnix</a></h4>
			<pre>func (l *UnixListener) AcceptUnix() (*UnixConn, error)</pre>
			<p>AcceptUnix accepts the next incoming call and returns the new connection
and the remote address.
</p>
		
			<h4 id="Addr">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#394">Addr</a></h4>
			<pre>func (l *UnixListener) Addr() Addr</pre>
			<p>Addr returns the listener&#39;s network address.
</p>
		
			<h4 id="Close">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#370">Close</a></h4>
			<pre>func (l *UnixListener) Close() error</pre>
			<p>Close stops listening on the Unix address.
Already accepted connections are not closed.
</p>
		
			<h4 id="File">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#408">File</a></h4>
			<pre>func (l *UnixListener) File() (f *os.File, err error)</pre>
			<p>File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
</p>
		
			<h4 id="SetDeadline">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release#398">SetDeadline</a></h4>
			<pre>func (l *UnixListener) SetDeadline(t time.Time) (err error)</pre>
			<p>SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.
</p>
		
	
		<h3 id="UnknownNetworkError">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#248">UnknownNetworkError</a></h3>
		<pre class="pre-x-scrollable">type UnknownNetworkError string</pre>
		<p></p>
		
		
			<h4 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#250">Error</a></h4>
			<pre>func (e UnknownNetworkError) Error() string</pre>
			<p></p>
		
			<h4 id="Temporary">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#251">Temporary</a></h4>
			<pre>func (e UnknownNetworkError) Temporary() bool</pre>
			<p></p>
		
			<h4 id="Timeout">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release#252">Timeout</a></h4>
			<pre>func (e UnknownNetworkError) Timeout() bool</pre>
			<p></p>
		
	

<h3 id="_files"><a href="http://code.google.com/p/go/source/browse/src/pkg/net?name=release">Files</a></h3>
<p>


	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/fd.go?name=release">fd.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/file.go?name=release">file.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/sockoptip.go?name=release">sockoptip.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock_posix.go?name=release">udpsock_posix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock.go?name=release">unixsock.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsclient.go?name=release">dnsclient.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface.go?name=release">interface.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/net.go?name=release">net.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/sock.go?name=release">sock.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/sockoptip_linux.go?name=release">sockoptip_linux.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/doc.go?name=release">doc.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/sendfile_linux.go?name=release">sendfile_linux.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release">tcpsock_posix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock_posix.go?name=release">iprawsock_posix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/ipsock.go?name=release">ipsock.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/unixsock_posix.go?name=release">unixsock_posix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsconfig.go?name=release">dnsconfig.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/net_posix.go?name=release">net_posix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/sockopt.go?name=release">sockopt.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/sockopt_linux.go?name=release">sockopt_linux.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/tcpsock.go?name=release">tcpsock.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/port.go?name=release">port.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/hosts.go?name=release">hosts.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/iprawsock.go?name=release">iprawsock.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsclient_unix.go?name=release">dnsclient_unix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/dnsmsg.go?name=release">dnsmsg.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/dial.go?name=release">dial.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/sock_linux.go?name=release">sock_linux.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/interface_linux.go?name=release">interface_linux.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/ip.go?name=release">ip.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/mac.go?name=release">mac.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/newpollserver.go?name=release">newpollserver.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/fd_linux.go?name=release">fd_linux.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/lookup_unix.go?name=release">lookup_unix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/parse.go?name=release">parse.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/udpsock.go?name=release">udpsock.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/ipsock_posix.go?name=release">ipsock_posix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/pipe.go?name=release">pipe.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/cgo_unix.go?name=release">cgo_unix.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/cgo_linux.go?name=release">cgo_linux.go</a>


</p>
		</div>
		<div class="container">
			<div class="flat-well well-small">
				<a href="https://github.com/Unknwon">@Unknown</a>
				<span class="muted">|</span>
				<a href="mailto:joe2010xtmf@163.com">Feedback</a>
				<span class="muted">|</span>
				<a href="https://github.com/Unknwon/gowalker/issues">Website Issues</a>
				<span class="pull-right"><a href="#">Back to top</a></span>
			</div>
		</div>
		<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40109089-2', 'gowalker.org');
  ga('send', 'pageview');

</script>
	</body>
</html>