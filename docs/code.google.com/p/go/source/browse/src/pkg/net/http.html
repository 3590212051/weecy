<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		
		<meta name="author" content="Unknown"/>

		 
		<link href="/static/css/bootstrap.css" rel="stylesheet" />
		<title>Go Walker</title>
	</head>

	<body>
		<div class="container">
			<div class="navbar navbar-inverse">
				<div class="navbar-inner">
					<a class="brand" href="/">Go Walker</a>
							<ul class="nav">
			<li><a href="/">Home</a></li>
			<li><a href="/-/index">Index</a></li>
			<li><a href="/-/about">About</a></li>
		</ul>
		<form class="navbar-search pull-right" action="/">
			<input class="search-query" type="text" placeholder="Search" name="q"></input>
		</form>
	</div>
</div>
<div class="flat-well well-small">
	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http?name=release"><strong>http:</strong></a> <a href="/search?q=code.google.com%2fp%2fgo%2fsource%2fbrowse%2fsrc%2fpkg%2fnet">code.google.com/p/go/source/browse/src/pkg/net/</a><span class="muted">http</span>
	<span class="pull-right"><a href="#_index">Index</a><span class="muted"> | </span><a href="#_files">Files</a><span class="muted"> | </span><a href="#_subdirs">Directories</a></span>
</div>
<h2>package http</h2>
<p><code>import "net/http"</code></p>
<pre>Package http provides HTTP client and server implementations.</pre>
<p>Get, Head, Post, and PostForm make HTTP requests:

	resp, err := http.Get(&#34;http://example.com/&#34;)
	...
	resp, err := http.Post(&#34;http://example.com/upload&#34;, &#34;image/jpeg&#34;, &amp;buf)
	...
	resp, err := http.PostForm(&#34;http://example.com/form&#34;,
		url.Values{&#34;key&#34;: {&#34;Value&#34;}, &#34;id&#34;: {&#34;123&#34;}})

The client must close the response body when finished with it:

	resp, err := http.Get(&#34;http://example.com/&#34;)
	if err != nil {
		// handle error
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	// ...

For control over HTTP client headers, redirect policy, and other
settings, create a Client:

	client := &amp;http.Client{
		CheckRedirect: redirectPolicyFunc,
	}

	resp, err := client.Get(&#34;http://example.com&#34;)
	// ...

	req, err := http.NewRequest(&#34;GET&#34;, &#34;http://example.com&#34;, nil)
	// ...
	req.Header.Add(&#34;If-None-Match&#34;, `W/&#34;wyzzy&#34;`)
	resp, err := client.Do(req)
	// ...

For control over proxies, TLS configuration, keep-alives,
compression, and other settings, create a Transport:

	tr := &amp;http.Transport{
		TLSClientConfig:    &amp;tls.Config{RootCAs: pool},
		DisableCompression: true,
	}
	client := &amp;http.Client{Transport: tr}
	resp, err := client.Get(&#34;https://example.com&#34;)

Clients and Transports are safe for concurrent use by multiple
goroutines and for efficiency should only be created once and re-used.

ListenAndServe starts an HTTP server with a given address and handler.
The handler is usually nil, which means to use DefaultServeMux.
Handle and HandleFunc add handlers to DefaultServeMux:

	http.Handle(&#34;/foo&#34;, fooHandler)

	http.HandleFunc(&#34;/bar&#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &#34;Hello, %q&#34;, html.EscapeString(r.URL.Path))
	})

	log.Fatal(http.ListenAndServe(&#34;:8080&#34;, nil))

More control over the server&#39;s behavior is available by creating a
custom Server:

	s := &amp;http.Server{
		Addr:           &#34;:8080&#34;,
		Handler:        myHandler,
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 &lt;&lt; 20,
	}
	log.Fatal(s.ListenAndServe())</p>
<p></p>

<h3 id="_index">Index</h3>
<ul class="unstyled">
<li><a href="#_constants">Constants</a></li>
<li><a href="#_variables">Variables</a></li>
<li><a href="#CanonicalHeaderKey">func CanonicalHeaderKey(s string) string</a></li><li><a href="#DetectContentType">func DetectContentType(data []byte) string</a></li><li><a href="#Error">func Error(w ResponseWriter, error string, code int)</a></li><li><a href="#Handle">func Handle(pattern string, handler Handler)</a></li><li><a href="#HandleFunc">func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</a></li><li><a href="#ListenAndServe">func ListenAndServe(addr string, handler Handler) error</a></li><li><a href="#ListenAndServeTLS">func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error</a></li><li><a href="#MaxBytesReader">func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser</a></li><li><a href="#NotFound">func NotFound(w ResponseWriter, r *Request)</a></li><li><a href="#ParseHTTPVersion">func ParseHTTPVersion(vers string) (major, minor int, ok bool)</a></li><li><a href="#ProxyFromEnvironment">func ProxyFromEnvironment(req *Request) (*url.URL, error)</a></li><li><a href="#ProxyURL">func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)</a></li><li><a href="#Redirect">func Redirect(w ResponseWriter, r *Request, urlStr string, code int)</a></li><li><a href="#Serve">func Serve(l net.Listener, handler Handler) error</a></li><li><a href="#ServeContent">func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)</a></li><li><a href="#ServeFile">func ServeFile(w ResponseWriter, r *Request, name string)</a></li><li><a href="#SetCookie">func SetCookie(w ResponseWriter, cookie *Cookie)</a></li><li><a href="#StatusText">func StatusText(code int) string</a></li>
<li><a href="#Client">type Client</a></li>

<ul><li><a href="#Do">func (c *Client) Do(req *Request) (resp *Response, err error)</a></li>
</ul><ul><li><a href="#Get">func (c *Client) Get(url string) (resp *Response, err error)</a></li>
</ul><ul><li><a href="#Head">func (c *Client) Head(url string) (resp *Response, err error)</a></li>
</ul><ul><li><a href="#Post">func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</a></li>
</ul><ul><li><a href="#PostForm">func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</a></li>
</ul><li><a href="#Cookie">type Cookie</a></li>

<ul><li><a href="#String">func (c *Cookie) String() string</a></li>
</ul><li><a href="#CookieJar">type CookieJar</a></li>

<li><a href="#Dir">type Dir</a></li>

<ul><li><a href="#Open">func (d Dir) Open(name string) (File, error)</a></li>
</ul><li><a href="#File">type File</a></li>

<li><a href="#FileSystem">type FileSystem</a></li>

<li><a href="#Flusher">type Flusher</a></li>

<li><a href="#Handler">type Handler</a></li>
<ul><li><a href="#FileServer">func FileServer(root FileSystem) Handler</a></li></ul><ul><li><a href="#NotFoundHandler">func NotFoundHandler() Handler</a></li></ul><ul><li><a href="#RedirectHandler">func RedirectHandler(url string, code int) Handler</a></li></ul><ul><li><a href="#StripPrefix">func StripPrefix(prefix string, h Handler) Handler</a></li></ul><ul><li><a href="#TimeoutHandler">func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler</a></li></ul>
<li><a href="#HandlerFunc">type HandlerFunc</a></li>

<ul><li><a href="#ServeHTTP">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</a></li>
</ul><li><a href="#Header">type Header</a></li>

<ul><li><a href="#Add">func (h Header) Add(key, value string)</a></li>
</ul><ul><li><a href="#Del">func (h Header) Del(key string)</a></li>
</ul><ul><li><a href="#Get">func (h Header) Get(key string) string</a></li>
</ul><ul><li><a href="#Set">func (h Header) Set(key, value string)</a></li>
</ul><ul><li><a href="#Write">func (h Header) Write(w io.Writer) error</a></li>
</ul><ul><li><a href="#WriteSubset">func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error</a></li>
</ul><li><a href="#Hijacker">type Hijacker</a></li>

<li><a href="#ProtocolError">type ProtocolError</a></li>

<ul><li><a href="#Error">func (err *ProtocolError) Error() string</a></li>
</ul><li><a href="#Request">type Request</a></li>
<ul><li><a href="#NewRequest">func NewRequest(method, urlStr string, body io.Reader) (*Request, error)</a></li></ul><ul><li><a href="#ReadRequest">func ReadRequest(b *bufio.Reader) (req *Request, err error)</a></li></ul>
<ul><li><a href="#AddCookie">func (r *Request) AddCookie(c *Cookie)</a></li>
</ul><ul><li><a href="#Cookie">func (r *Request) Cookie(name string) (*Cookie, error)</a></li>
</ul><ul><li><a href="#Cookies">func (r *Request) Cookies() []*Cookie</a></li>
</ul><ul><li><a href="#FormFile">func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)</a></li>
</ul><ul><li><a href="#FormValue">func (r *Request) FormValue(key string) string</a></li>
</ul><ul><li><a href="#MultipartReader">func (r *Request) MultipartReader() (*multipart.Reader, error)</a></li>
</ul><ul><li><a href="#ParseForm">func (r *Request) ParseForm() (err error)</a></li>
</ul><ul><li><a href="#ParseMultipartForm">func (r *Request) ParseMultipartForm(maxMemory int64) error</a></li>
</ul><ul><li><a href="#ProtoAtLeast">func (r *Request) ProtoAtLeast(major, minor int) bool</a></li>
</ul><ul><li><a href="#Referer">func (r *Request) Referer() string</a></li>
</ul><ul><li><a href="#SetBasicAuth">func (r *Request) SetBasicAuth(username, password string)</a></li>
</ul><ul><li><a href="#UserAgent">func (r *Request) UserAgent() string</a></li>
</ul><ul><li><a href="#Write">func (r *Request) Write(w io.Writer) error</a></li>
</ul><ul><li><a href="#WriteProxy">func (r *Request) WriteProxy(w io.Writer) error</a></li>
</ul><li><a href="#Response">type Response</a></li>
<ul><li><a href="#Get">func Get(url string) (resp *Response, err error)</a></li></ul><ul><li><a href="#Head">func Head(url string) (resp *Response, err error)</a></li></ul><ul><li><a href="#Post">func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</a></li></ul><ul><li><a href="#PostForm">func PostForm(url string, data url.Values) (resp *Response, err error)</a></li></ul><ul><li><a href="#ReadResponse">func ReadResponse(r *bufio.Reader, req *Request) (resp *Response, err error)</a></li></ul>
<ul><li><a href="#Cookies">func (r *Response) Cookies() []*Cookie</a></li>
</ul><ul><li><a href="#Location">func (r *Response) Location() (*url.URL, error)</a></li>
</ul><ul><li><a href="#ProtoAtLeast">func (r *Response) ProtoAtLeast(major, minor int) bool</a></li>
</ul><ul><li><a href="#Write">func (r *Response) Write(w io.Writer) error</a></li>
</ul><li><a href="#ResponseWriter">type ResponseWriter</a></li>

<li><a href="#RoundTripper">type RoundTripper</a></li>
<ul><li><a href="#NewFileTransport">func NewFileTransport(fs FileSystem) RoundTripper</a></li></ul>
<li><a href="#ServeMux">type ServeMux</a></li>
<ul><li><a href="#NewServeMux">func NewServeMux() *ServeMux</a></li></ul>
<ul><li><a href="#Handle">func (mux *ServeMux) Handle(pattern string, handler Handler)</a></li>
</ul><ul><li><a href="#HandleFunc">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</a></li>
</ul><ul><li><a href="#ServeHTTP">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</a></li>
</ul><li><a href="#Server">type Server</a></li>

<ul><li><a href="#ListenAndServe">func (srv *Server) ListenAndServe() error</a></li>
</ul><ul><li><a href="#ListenAndServeTLS">func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error</a></li>
</ul><ul><li><a href="#Serve">func (srv *Server) Serve(l net.Listener) error</a></li>
</ul><li><a href="#Transport">type Transport</a></li>

<ul><li><a href="#CloseIdleConnections">func (t *Transport) CloseIdleConnections()</a></li>
</ul><ul><li><a href="#RegisterProtocol">func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)</a></li>
</ul><ul><li><a href="#RoundTrip">func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)</a></li>
</ul></ul>
<h3 id="_constants">Constants</h3>
<pre class="pre-x-scrollable">const (
    StatusContinue           = 100
    StatusSwitchingProtocols = 101

    StatusOK                   = 200
    StatusCreated              = 201
    StatusAccepted             = 202
    StatusNonAuthoritativeInfo = 203
    StatusNoContent            = 204
    StatusResetContent         = 205
    StatusPartialContent       = 206

    StatusMultipleChoices   = 300
    StatusMovedPermanently  = 301
    StatusFound             = 302
    StatusSeeOther          = 303
    StatusNotModified       = 304
    StatusUseProxy          = 305
    StatusTemporaryRedirect = 307

    StatusBadRequest                   = 400
    StatusUnauthorized                 = 401
    StatusPaymentRequired              = 402
    StatusForbidden                    = 403
    StatusNotFound                     = 404
    StatusMethodNotAllowed             = 405
    StatusNotAcceptable                = 406
    StatusProxyAuthRequired            = 407
    StatusRequestTimeout               = 408
    StatusConflict                     = 409
    StatusGone                         = 410
    StatusLengthRequired               = 411
    StatusPreconditionFailed           = 412
    StatusRequestEntityTooLarge        = 413
    StatusRequestURITooLong            = 414
    StatusUnsupportedMediaType         = 415
    StatusRequestedRangeNotSatisfiable = 416
    StatusExpectationFailed            = 417
    StatusTeapot                       = 418

    StatusInternalServerError     = 500
    StatusNotImplemented          = 501
    StatusBadGateway              = 502
    StatusServiceUnavailable      = 503
    StatusGatewayTimeout          = 504
    StatusHTTPVersionNotSupported = 505
)</pre><pre class="pre-x-scrollable">const DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB
</pre><pre class="pre-x-scrollable">const DefaultMaxIdleConnsPerHost = 2</pre><pre class="pre-x-scrollable">const TimeFormat = &#34;Mon, 02 Jan 2006 15:04:05 GMT&#34;</pre>
<p></p>
<h3 id="_variables">Variables</h3>
<pre class="pre-x-scrollable">var (
    ErrHeaderTooLong        = &amp;ProtocolError{&#34;header too long&#34;}
    ErrShortBody            = &amp;ProtocolError{&#34;entity body too short&#34;}
    ErrNotSupported         = &amp;ProtocolError{&#34;feature not supported&#34;}
    ErrUnexpectedTrailer    = &amp;ProtocolError{&#34;trailer header without chunked transfer encoding&#34;}
    ErrMissingContentLength = &amp;ProtocolError{&#34;missing ContentLength in HEAD response&#34;}
    ErrNotMultipart         = &amp;ProtocolError{&#34;request Content-Type isn&#39;t multipart/form-data&#34;}
    ErrMissingBoundary      = &amp;ProtocolError{&#34;no multipart boundary param Content-Type&#34;}
)</pre><pre class="pre-x-scrollable">var (
    ErrWriteAfterFlush = errors.New(&#34;Conn.Write called after Flush&#34;)
    ErrBodyNotAllowed  = errors.New(&#34;http: request method or response status code does not allow body&#34;)
    ErrHijacked        = errors.New(&#34;Conn has been hijacked&#34;)
    ErrContentLength   = errors.New(&#34;Conn.Write wrote more than the declared Content-Length&#34;)
)</pre><pre class="pre-x-scrollable">var DefaultClient = &amp;Client{}</pre><pre class="pre-x-scrollable">var DefaultServeMux = NewServeMux()</pre><pre class="pre-x-scrollable">var ErrBodyReadAfterClose = errors.New(&#34;http: invalid Read on closed request Body&#34;)</pre><pre class="pre-x-scrollable">var ErrHandlerTimeout = errors.New(&#34;http: Handler timeout&#34;)</pre><pre class="pre-x-scrollable">var ErrLineTooLong = errors.New(&#34;header line too long&#34;)</pre><pre class="pre-x-scrollable">var ErrMissingFile = errors.New(&#34;http: no such file&#34;)</pre><pre class="pre-x-scrollable">var ErrNoCookie = errors.New(&#34;http: named cookie not present&#34;)</pre><pre class="pre-x-scrollable">var ErrNoLocation = errors.New(&#34;http: no Location header in response&#34;)</pre>
<p></p>

	
		<h3 id="CanonicalHeaderKey">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release#78">CanonicalHeaderKey</a></h3>
		<pre>func CanonicalHeaderKey(s string) string</pre>
		<p>CanonicalHeaderKey returns the canonical format of the
header key s.  The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase.  For example, the
canonical key for &#34;accept-encoding&#34; is &#34;Accept-Encoding&#34;.
</p>
	
		<h3 id="DetectContentType">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/sniff.go?name=release#21">DetectContentType</a></h3>
		<pre>func DetectContentType(data []byte) string</pre>
		<p>DetectContentType implements the algorithm described
at http://mimesniff.spec.whatwg.org/ to determine the
Content-Type of the given data.  It considers at most the
first 512 bytes of data.  DetectContentType always returns
a valid MIME type: if it cannot determine a more specific one, it
returns &#34;application/octet-stream&#34;.
</p>
	
		<h3 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#709">Error</a></h3>
		<pre>func Error(w ResponseWriter, error string, code int)</pre>
		<p>Error replies to the request with the specified error message and HTTP code.
</p>
	
		<h3 id="Handle">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#979">Handle</a></h3>
		<pre>func Handle(pattern string, handler Handler)</pre>
		<p>Handle registers the handler for the given pattern
in the DefaultServeMux.
The documentation for ServeMux explains how patterns are matched.
</p>
	
		<h3 id="HandleFunc">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#984">HandleFunc</a></h3>
		<pre>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</pre>
		<p>HandleFunc registers the handler function for the given pattern
in the DefaultServeMux.
The documentation for ServeMux explains how patterns are matched.
</p>
	
		<h3 id="ListenAndServe">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#1089">ListenAndServe</a></h3>
		<pre>func ListenAndServe(addr string, handler Handler) error</pre>
		<p>ListenAndServe listens on the TCP network address addr
and then calls Serve with handler to handle requests
on incoming connections.  Handler is typically nil,
in which case the DefaultServeMux is used.

A trivial example server is:

	package main

	import (
		&#34;io&#34;
		&#34;net/http&#34;
		&#34;log&#34;
	)

	// hello world, the web server
	func HelloServer(w http.ResponseWriter, req *http.Request) {
		io.WriteString(w, &#34;hello, world!\n&#34;)
	}

	func main() {
		http.HandleFunc(&#34;/hello&#34;, HelloServer)
		err := http.ListenAndServe(&#34;:12345&#34;, nil)
		if err != nil {
			log.Fatal(&#34;ListenAndServe: &#34;, err)
		}
	}
</p>
	
		<h3 id="ListenAndServeTLS">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#1122">ListenAndServeTLS</a></h3>
		<pre>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error</pre>
		<p>ListenAndServeTLS acts identically to ListenAndServe, except that it
expects HTTPS connections. Additionally, files containing a certificate and
matching private key for the server must be provided. If the certificate
is signed by a certificate authority, the certFile should be the concatenation
of the server&#39;s certificate followed by the CA&#39;s certificate.

A trivial example server is:

	import (
		&#34;log&#34;
		&#34;net/http&#34;
	)

	func handler(w http.ResponseWriter, req *http.Request) {
		w.Header().Set(&#34;Content-Type&#34;, &#34;text/plain&#34;)
		w.Write([]byte(&#34;This is an example server.\n&#34;))
	}

	func main() {
		http.HandleFunc(&#34;/&#34;, handler)
		log.Printf(&#34;About to listen on 10443. Go to https://127.0.0.1:10443/&#34;)
		err := http.ListenAndServeTLS(&#34;:10443&#34;, &#34;cert.pem&#34;, &#34;key.pem&#34;, nil)
		if err != nil {
			log.Fatal(err)
		}
	}

One can use generate_cert.go in crypto/tls to generate cert.pem and key.pem.
</p>
	
		<h3 id="MaxBytesReader">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#564">MaxBytesReader</a></h3>
		<pre>func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser</pre>
		<p>MaxBytesReader is similar to io.LimitReader but is intended for
limiting the size of incoming request bodies. In contrast to
io.LimitReader, MaxBytesReader&#39;s result is a ReadCloser, returns a
non-EOF error for a Read beyond the limit, and Closes the
underlying reader when its Close method is called.

MaxBytesReader prevents clients from accidentally or maliciously
sending a large request and wasting server resources.
</p>
	
		<h3 id="NotFound">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#716">NotFound</a></h3>
		<pre>func NotFound(w ResponseWriter, r *Request)</pre>
		<p>NotFound replies to the request with an HTTP 404 not found error.
</p>
	
		<h3 id="ParseHTTPVersion">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#392">ParseHTTPVersion</a></h3>
		<pre>func ParseHTTPVersion(vers string) (major, minor int, ok bool)</pre>
		<p>ParseHTTPVersion parses a HTTP version string.
&#34;HTTP/1.0&#34; returns (1, 0, true).
</p>
	
		<h3 id="ProxyFromEnvironment">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/transport.go?name=release#83">ProxyFromEnvironment</a></h3>
		<pre>func ProxyFromEnvironment(req *Request) (*url.URL, error)</pre>
		<p>ProxyFromEnvironment returns the URL of the proxy to use for a
given request, as indicated by the environment variables
$HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy).
An error is returned if the proxy environment is invalid.
A nil URL and nil error are returned if no proxy is defined in the
environment, or a proxy should not be used for the given request.
</p>
	
		<h3 id="ProxyURL">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/transport.go?name=release#106">ProxyURL</a></h3>
		<pre>func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)</pre>
		<p>ProxyURL returns a proxy function (for use in a Transport)
that always returns the same URL.
</p>
	
		<h3 id="Redirect">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#740">Redirect</a></h3>
		<pre>func Redirect(w ResponseWriter, r *Request, urlStr string, code int)</pre>
		<p>Redirect replies to the request with a redirect to url,
which may be a path relative to the request path.
</p>
	
		<h3 id="Serve">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#992">Serve</a></h3>
		<pre>func Serve(l net.Listener, handler Handler) error</pre>
		<p>Serve accepts incoming HTTP connections on the listener l,
creating a new service thread for each.  The service threads
read requests and then call handler to reply to them.
Handler is typically nil, in which case the DefaultServeMux is used.
</p>
	
		<h3 id="ServeContent">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/fs.go?name=release#104">ServeContent</a></h3>
		<pre>func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)</pre>
		<p>ServeContent replies to the request using the content in the
provided ReadSeeker.  The main benefit of ServeContent over io.Copy
is that it handles Range requests properly, sets the MIME type, and
handles If-Modified-Since requests.

If the response&#39;s Content-Type header is not set, ServeContent
first tries to deduce the type from name&#39;s file extension and,
if that fails, falls back to reading the first block of the content
and passing it to DetectContentType.
The name is otherwise unused; in particular it can be empty and is
never sent in the response.

If modtime is not the zero time, ServeContent includes it in a
Last-Modified header in the response.  If the request includes an
If-Modified-Since header, ServeContent uses modtime to decide
whether the content needs to be sent at all.

The content&#39;s Seek method must work: ServeContent uses
a seek to the end of the content to determine its size.

Note that *os.File implements the io.ReadSeeker interface.
</p>
	
		<h3 id="ServeFile">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/fs.go?name=release#333">ServeFile</a></h3>
		<pre>func ServeFile(w ResponseWriter, r *Request, name string)</pre>
		<p>ServeFile replies to the request with the contents of the named file or directory.
</p>
	
		<h3 id="SetCookie">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/cookie.go?name=release#133">SetCookie</a></h3>
		<pre>func SetCookie(w ResponseWriter, cookie *Cookie)</pre>
		<p>SetCookie adds a Set-Cookie header to the provided ResponseWriter&#39;s headers.
</p>
	
		<h3 id="StatusText">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/status.go?name=release#106">StatusText</a></h3>
		<pre>func StatusText(code int) string</pre>
		<p>StatusText returns a text for the HTTP status code. It returns the empty
string if the code is unknown.
</p>
	


	
		<h3 id="Client">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#28">Client</a></h3>
		<pre class="pre-x-scrollable">type Client struct {
    // Transport specifies the mechanism by which individual
    // HTTP requests are made.
    // If nil, DefaultTransport is used.
    Transport RoundTripper

    // CheckRedirect specifies the policy for handling redirects.
    // If CheckRedirect is not nil, the client calls it before
    // following an HTTP redirect. The arguments req and via
    // are the upcoming request and the requests made already,
    // oldest first. If CheckRedirect returns an error, the client
    // returns that error (wrapped in a url.Error) instead of
    // issuing the Request req.
    //
    // If CheckRedirect is nil, the Client uses its default policy,
    // which is to stop after 10 consecutive requests.
    CheckRedirect func(req *Request, via []*Request) error

    // Jar specifies the cookie jar.
    // If Jar is nil, cookies are not sent in requests and ignored
    // in responses.
    Jar CookieJar
}</pre>
		<p>A Client is an HTTP client. Its zero value (DefaultClient) is a usable client
that uses DefaultTransport.

The Client&#39;s Transport typically has internal state (cached
TCP connections), so Clients should be reused instead of created as
needed. Clients are safe for concurrent use by multiple goroutines.
</p>
		
		
			<h4 id="Do">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#104">Do</a></h4>
			<pre>func (c *Client) Do(req *Request) (resp *Response, err error)</pre>
			<p>Do sends an HTTP request and returns an HTTP response, following
policy (e.g. redirects, cookies, auth) as configured on the client.

An error is returned if caused by client policy (such as
CheckRedirect), or if there was an HTTP protocol error.
A non-2xx response doesn&#39;t cause an error.

When err is nil, resp always contains a non-nil resp.Body.

Callers should close res.Body when done reading from it. If
resp.Body is not closed, the Client&#39;s underlying RoundTripper
(typically Transport) may not be able to re-use a persistent TCP
connection to the server for a subsequent &#34;keep-alive&#34; request.

Generally Get, Post, or PostForm will be used instead of Do.
</p>
		
			<h4 id="Get">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#195">Get</a></h4>
			<pre>func (c *Client) Get(url string) (resp *Response, err error)</pre>
			<p>Get issues a GET to the specified URL.  If the response is one of the
following redirect codes, Get follows the redirect after calling the
Client&#39;s CheckRedirect function.

   301 (Moved Permanently)
   302 (Found)
   303 (See Other)
   307 (Temporary Redirect)

An error is returned if the Client&#39;s CheckRedirect function fails
or if there was an HTTP protocol error. A non-2xx response doesn&#39;t
cause an error.

When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.
</p>
		
			<h4 id="Head">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#362">Head</a></h4>
			<pre>func (c *Client) Head(url string) (resp *Response, err error)</pre>
			<p>Head issues a HEAD to the specified URL.  If the response is one of the
following redirect codes, Head follows the redirect after calling the
Client&#39;s CheckRedirect function.

   301 (Moved Permanently)
   302 (Found)
   303 (See Other)
   307 (Temporary Redirect)
</p>
		
			<h4 id="Post">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#302">Post</a></h4>
			<pre>func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</pre>
			<p>Post issues a POST to the specified URL.

Caller should close resp.Body when done reading from it.
</p>
		
			<h4 id="PostForm">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#336">PostForm</a></h4>
			<pre>func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</pre>
			<p>PostForm issues a POST to the specified URL,
with data&#39;s keys and values urlencoded as the request body.

When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.
</p>
		
	
		<h3 id="Cookie">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/cookie.go?name=release#21">Cookie</a></h3>
		<pre class="pre-x-scrollable">type Cookie struct {
    Name       string
    Value      string
    Path       string
    Domain     string
    Expires    time.Time
    RawExpires string

    // MaxAge=0 means no &#39;Max-Age&#39; attribute specified.
    // MaxAge&lt;0 means delete cookie now, equivalently &#39;Max-Age: 0&#39;
    // MaxAge&gt;0 means Max-Age attribute present and given in seconds
    MaxAge   int
    Secure   bool
    HttpOnly bool
    Raw      string
    Unparsed []string // Raw text of unparsed attribute-value pairs
}</pre>
		<p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an
HTTP response or the Cookie header of an HTTP request.
</p>
		
		
			<h4 id="String">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/cookie.go?name=release#140">String</a></h4>
			<pre>func (c *Cookie) String() string</pre>
			<p>String returns the serialization of the cookie for use in a Cookie
header (if only Name and Value are set) or a Set-Cookie response
header (if other fields are set).
</p>
		
	
		<h3 id="CookieJar">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/jar.go?name=release#15">CookieJar</a></h3>
		<pre class="pre-x-scrollable">type CookieJar interface {
    // SetCookies handles the receipt of the cookies in a reply for the
    // given URL.  It may or may not choose to save the cookies, depending
    // on the jar&#39;s policy and implementation.
    SetCookies(u *url.URL, cookies []*Cookie)

    // Cookies returns the cookies to send in a request for the given URL.
    // It is up to the implementation to honor the standard cookie use
    // restrictions such as in RFC 6265.
    Cookies(u *url.URL) []*Cookie
}</pre>
		<p>A CookieJar manages storage and use of cookies in HTTP requests.

Implementations of CookieJar must be safe for concurrent use by multiple
goroutines.
</p>
		
		
	
		<h3 id="Dir">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/fs.go?name=release#28">Dir</a></h3>
		<pre class="pre-x-scrollable">type Dir string</pre>
		<p>A Dir implements http.FileSystem using the native file
system restricted to a specific directory tree.

An empty Dir is treated as &#34;.&#34;.
</p>
		
		
			<h4 id="Open">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/fs.go?name=release#30">Open</a></h4>
			<pre>func (d Dir) Open(name string) (File, error)</pre>
			<p></p>
		
	
		<h3 id="File">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/fs.go?name=release#55">File</a></h3>
		<pre class="pre-x-scrollable">type File interface {
    Close() error
    Stat() (os.FileInfo, error)
    Readdir(count int) ([]os.FileInfo, error)
    Read([]byte) (int, error)
    Seek(offset int64, whence int) (int64, error)
}</pre>
		<p>A File is returned by a FileSystem&#39;s Open method and can be
served by the FileServer implementation.
</p>
		
		
	
		<h3 id="FileSystem">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/fs.go?name=release#49">FileSystem</a></h3>
		<pre class="pre-x-scrollable">type FileSystem interface {
    Open(name string) (File, error)
}</pre>
		<p>A FileSystem implements access to a collection of named files.
The elements in a file path are separated by slash (&#39;/&#39;, U&#43;002F)
characters, regardless of host operating system convention.
</p>
		
		
	
		<h3 id="Flusher">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#81">Flusher</a></h3>
		<pre class="pre-x-scrollable">type Flusher interface {
    // Flush sends any buffered data to the client.
    Flush()
}</pre>
		<p>The Flusher interface is implemented by ResponseWriters that allow
an HTTP handler to flush buffered data to the client.

Note that even for ResponseWriters that support Flush,
if the client is connected through an HTTP proxy,
the buffered data may not reach the client until the response
completes.
</p>
		
		
	
		<h3 id="Handler">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#47">Handler</a></h3>
		<pre class="pre-x-scrollable">type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}</pre>
		<p>Objects implementing the Handler interface can be
registered to serve a particular path or subtree
in the HTTP server.

ServeHTTP should write reply headers and data to the ResponseWriter
and then return.  Returning signals that the request is finished
and that the HTTP server can move on to the next request on
the connection.
</p>
		
			<h4 id="FileServer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/fs.go?name=release#349">FileServer</a></h4>
			<pre>func FileServer(root FileSystem) Handler</pre>
			<p>FileServer returns a handler that serves HTTP requests
with the contents of the file system rooted at root.

To use the operating system&#39;s file system implementation,
use http.Dir:

    http.Handle(&#34;/&#34;, http.FileServer(http.Dir(&#34;/tmp&#34;)))
</p>
		
			<h4 id="NotFoundHandler">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#720">NotFoundHandler</a></h4>
			<pre>func NotFoundHandler() Handler</pre>
			<p>NotFoundHandler returns a simple request handler
that replies to each request with a ``404 page not found&#39;&#39; reply.
</p>
		
			<h4 id="RedirectHandler">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#824">RedirectHandler</a></h4>
			<pre>func RedirectHandler(url string, code int) Handler</pre>
			<p>RedirectHandler returns a request handler that redirects
each request it receives to the given url using the given
status code.
</p>
		
			<h4 id="StripPrefix">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#727">StripPrefix</a></h4>
			<pre>func StripPrefix(prefix string, h Handler) Handler</pre>
			<p>StripPrefix returns a handler that serves HTTP requests
by removing the given prefix from the request URL&#39;s Path
and invoking the handler h. StripPrefix handles a
request for a path that doesn&#39;t begin with prefix by
replying with an HTTP 404 not found error.
</p>
		
			<h4 id="TimeoutHandler">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#1173">TimeoutHandler</a></h4>
			<pre>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler</pre>
			<p>TimeoutHandler returns a Handler that runs h with the given time limit.

The new Handler calls h.ServeHTTP to handle each request, but if a
call runs for more than ns nanoseconds, the handler responds with
a 503 Service Unavailable error and the given message in its body.
(If msg is empty, a suitable default message will be sent.)
After such a timeout, writes by h to its ResponseWriter will return
ErrHandlerTimeout.
</p>
		
		
	
		<h3 id="HandlerFunc">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#699">HandlerFunc</a></h3>
		<pre class="pre-x-scrollable">type HandlerFunc func(ResponseWriter, *Request)</pre>
		<p>The HandlerFunc type is an adapter to allow the use of
ordinary functions as HTTP handlers.  If f is a function
with the appropriate signature, HandlerFunc(f) is a
Handler object that calls f.
</p>
		
		
			<h4 id="ServeHTTP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#702">ServeHTTP</a></h4>
			<pre>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</pre>
			<p>ServeHTTP calls f(w, r).
</p>
		
	
		<h3 id="Header">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release#16">Header</a></h3>
		<pre class="pre-x-scrollable">type Header map[string][]string</pre>
		<p>A Header represents the key-value pairs in an HTTP header.
</p>
		
		
			<h4 id="Add">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release#20">Add</a></h4>
			<pre>func (h Header) Add(key, value string)</pre>
			<p>Add adds the key, value pair to the header.
It appends to any existing values associated with key.
</p>
		
			<h4 id="Del">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release#40">Del</a></h4>
			<pre>func (h Header) Del(key string)</pre>
			<p>Del deletes the values associated with key.
</p>
		
			<h4 id="Get">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release#35">Get</a></h4>
			<pre>func (h Header) Get(key string) string</pre>
			<p>Get gets the first value associated with the given key.
If there are no values associated with the key, Get returns &#34;&#34;.
To access multiple values of a key, access the map directly
with CanonicalHeaderKey.
</p>
		
			<h4 id="Set">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release#27">Set</a></h4>
			<pre>func (h Header) Set(key, value string)</pre>
			<p>Set sets the header entries associated with key to
the single element value.  It replaces any existing
values associated with key.
</p>
		
			<h4 id="Write">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release#45">Write</a></h4>
			<pre>func (h Header) Write(w io.Writer) error</pre>
			<p>Write writes a header in wire format.
</p>
		
			<h4 id="WriteSubset">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release#53">WriteSubset</a></h4>
			<pre>func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error</pre>
			<p>WriteSubset writes a header in wire format.
If exclude is not nil, keys where exclude[key] == true are not written.
</p>
		
	
		<h3 id="Hijacker">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#88">Hijacker</a></h3>
		<pre class="pre-x-scrollable">type Hijacker interface {
    // Hijack lets the caller take over the connection.
    // After a call to Hijack(), the HTTP server library
    // will not do anything else with the connection.
    // It becomes the caller&#39;s responsibility to manage
    // and close the connection.
    Hijack() (net.Conn, *bufio.ReadWriter, error)
}</pre>
		<p>The Hijacker interface is implemented by ResponseWriters that allow
an HTTP handler to take over the connection.
</p>
		
		
	
		<h3 id="ProtocolError">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#37">ProtocolError</a></h3>
		<pre class="pre-x-scrollable">type ProtocolError struct {
    ErrorString string
}</pre>
		<p>HTTP request parsing errors.
</p>
		
		
			<h4 id="Error">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#41">Error</a></h4>
			<pre>func (err *ProtocolError) Error() string</pre>
			<p></p>
		
	
		<h3 id="Request">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#71">Request</a></h3>
		<pre class="pre-x-scrollable">type Request struct {
    Method string // GET, POST, PUT, etc.
    URL    *url.URL

    // The protocol version for incoming requests.
    // Outgoing requests always use HTTP/1.1.
    Proto      string // &#34;HTTP/1.0&#34;
    ProtoMajor int    // 1
    ProtoMinor int    // 0

    // A header maps request lines to their values.
    // If the header says
    //
    //	accept-encoding: gzip, deflate
    //	Accept-Language: en-us
    //	Connection: keep-alive
    //
    // then
    //
    //	Header = map[string][]string{
    //		&#34;Accept-Encoding&#34;: {&#34;gzip, deflate&#34;},
    //		&#34;Accept-Language&#34;: {&#34;en-us&#34;},
    //		&#34;Connection&#34;: {&#34;keep-alive&#34;},
    //	}
    //
    // HTTP defines that header names are case-insensitive.
    // The request parser implements this by canonicalizing the
    // name, making the first character and any characters
    // following a hyphen uppercase and the rest lowercase.
    Header Header

    // The message body.
    Body io.ReadCloser

    // ContentLength records the length of the associated content.
    // The value -1 indicates that the length is unknown.
    // Values &gt;= 0 indicate that the given number of bytes may
    // be read from Body.
    // For outgoing requests, a value of 0 means unknown if Body is not nil.
    ContentLength int64

    // TransferEncoding lists the transfer encodings from outermost to
    // innermost. An empty list denotes the &#34;identity&#34; encoding.
    // TransferEncoding can usually be ignored; chunked encoding is
    // automatically added and removed as necessary when sending and
    // receiving requests.
    TransferEncoding []string

    // Close indicates whether to close the connection after
    // replying to this request.
    Close bool

    // The host on which the URL is sought.
    // Per RFC 2616, this is either the value of the Host: header
    // or the host name given in the URL itself.
    Host string

    // Form contains the parsed form data, including both the URL
    // field&#39;s query parameters and the POST or PUT form data.
    // This field is only available after ParseForm is called.
    // The HTTP client ignores Form and uses Body instead.
    Form url.Values

    // MultipartForm is the parsed multipart form, including file uploads.
    // This field is only available after ParseMultipartForm is called.
    // The HTTP client ignores MultipartForm and uses Body instead.
    MultipartForm *multipart.Form

    // Trailer maps trailer keys to values.  Like for Header, if the
    // response has multiple trailer lines with the same key, they will be
    // concatenated, delimited by commas.
    // For server requests, Trailer is only populated after Body has been
    // closed or fully consumed.
    // Trailer support is only partially complete.
    Trailer Header

    // RemoteAddr allows HTTP servers and other software to record
    // the network address that sent the request, usually for
    // logging. This field is not filled in by ReadRequest and
    // has no defined format. The HTTP server in this package
    // sets RemoteAddr to an &#34;IP:port&#34; address before invoking a
    // handler.
    // This field is ignored by the HTTP client.
    RemoteAddr string

    // RequestURI is the unmodified Request-URI of the
    // Request-Line (RFC 2616, Section 5.1) as sent by the client
    // to a server. Usually the URL field should be used instead.
    // It is an error to set this field in an HTTP client request.
    RequestURI string

    // TLS allows HTTP servers and other software to record
    // information about the TLS connection on which the request
    // was received. This field is not filled in by ReadRequest.
    // The HTTP server in this package sets the field for
    // TLS-enabled connections before invoking a handler;
    // otherwise it leaves the field nil.
    // This field is ignored by the HTTP client.
    TLS *tls.ConnectionState
}</pre>
		<p>A Request represents an HTTP request received by a server
or to be sent by a client.
</p>
		
			<h4 id="NewRequest">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#408">NewRequest</a></h4>
			<pre>func NewRequest(method, urlStr string, body io.Reader) (*Request, error)</pre>
			<p>NewRequest returns a new Request given a method, URL, and optional body.
</p>
		
			<h4 id="ReadRequest">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#450">ReadRequest</a></h4>
			<pre>func ReadRequest(b *bufio.Reader) (req *Request, err error)</pre>
			<p>ReadRequest reads and parses a request from b.
</p>
		
		
			<h4 id="AddCookie">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#204">AddCookie</a></h4>
			<pre>func (r *Request) AddCookie(c *Cookie)</pre>
			<p>AddCookie adds a cookie to the request.  Per RFC 6265 section 5.4,
AddCookie does not attach more than one Cookie header field.  That
means all cookies, if any, are written into the same line,
separated by semicolon.
</p>
		
			<h4 id="Cookie">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#193">Cookie</a></h4>
			<pre>func (r *Request) Cookie(name string) (*Cookie, error)</pre>
			<p>Cookie returns the named cookie provided in the request or
ErrNoCookie if not found.
</p>
		
			<h4 id="Cookies">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#185">Cookies</a></h4>
			<pre>func (r *Request) Cookies() []*Cookie</pre>
			<p>Cookies parses and returns the HTTP cookies sent with the request.
</p>
		
			<h4 id="FormFile">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#715">FormFile</a></h4>
			<pre>func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)</pre>
			<p>FormFile returns the first file for the provided form key.
FormFile calls ParseMultipartForm and ParseForm if necessary.
</p>
		
			<h4 id="FormValue">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#703">FormValue</a></h4>
			<pre>func (r *Request) FormValue(key string) string</pre>
			<p>FormValue returns the first value for the named component of the query.
FormValue calls ParseMultipartForm and ParseForm if necessary.
</p>
		
			<h4 id="MultipartReader">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#237">MultipartReader</a></h4>
			<pre>func (r *Request) MultipartReader() (*multipart.Reader, error)</pre>
			<p>MultipartReader returns a MIME multipart reader if this is a
multipart/form-data POST request, else returns nil and an error.
Use this function instead of ParseMultipartForm to
process the request body as a stream.
</p>
		
			<h4 id="ParseForm">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#605">ParseForm</a></h4>
			<pre>func (r *Request) ParseForm() (err error)</pre>
			<p>ParseForm parses the raw query from the URL.

For POST or PUT requests, it also parses the request body as a form.
If the request Body&#39;s size has not already been limited by MaxBytesReader,
the size is capped at 10MB.

ParseMultipartForm calls ParseForm automatically.
It is idempotent.
</p>
		
			<h4 id="ParseMultipartForm">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#668">ParseMultipartForm</a></h4>
			<pre>func (r *Request) ParseMultipartForm(maxMemory int64) error</pre>
			<p>ParseMultipartForm parses a request body as multipart/form-data.
The whole request body is parsed and up to a total of maxMemory bytes of
its file parts are stored in memory, with the remainder stored on
disk in temporary files.
ParseMultipartForm calls ParseForm if necessary.
After one call to ParseMultipartForm, subsequent calls have no effect.
</p>
		
			<h4 id="ProtoAtLeast">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#174">ProtoAtLeast</a></h4>
			<pre>func (r *Request) ProtoAtLeast(major, minor int) bool</pre>
			<p>ProtoAtLeast returns whether the HTTP protocol used
in the request is at least major.minor.
</p>
		
			<h4 id="Referer">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#221">Referer</a></h4>
			<pre>func (r *Request) Referer() string</pre>
			<p>Referer returns the referring URL, if sent in the request.

Referer is misspelled as in the request itself, a mistake from the
earliest days of HTTP.  This value can also be fetched from the
Header map as Header[&#34;Referer&#34;]; the benefit of making it available
as a method is that the compiler can diagnose programs that use the
alternate (correct English) spelling req.Referrer() but cannot
diagnose programs that use Header[&#34;Referrer&#34;].
</p>
		
			<h4 id="SetBasicAuth">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#444">SetBasicAuth</a></h4>
			<pre>func (r *Request) SetBasicAuth(username, password string)</pre>
			<p>SetBasicAuth sets the request&#39;s Authorization header to use HTTP
Basic Authentication with the provided username and password.

With HTTP Basic Authentication the provided username and password
are not encrypted.
</p>
		
			<h4 id="UserAgent">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#180">UserAgent</a></h4>
			<pre>func (r *Request) UserAgent() string</pre>
			<p>UserAgent returns the client&#39;s User-Agent, if sent in the request.
</p>
		
			<h4 id="Write">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#287">Write</a></h4>
			<pre>func (r *Request) Write(w io.Writer) error</pre>
			<p>Write writes an HTTP/1.1 request -- header and body -- in wire format.
This method consults the following fields of the request:
	Host
	URL
	Method (defaults to &#34;GET&#34;)
	Header
	ContentLength
	TransferEncoding
	Body

If Body is present, Content-Length is &lt;= 0 and TransferEncoding
hasn&#39;t been set to &#34;identity&#34;, Write adds &#34;Transfer-Encoding:
chunked&#34; to the header. Body is closed after it is sent.
</p>
		
			<h4 id="WriteProxy">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release#297">WriteProxy</a></h4>
			<pre>func (r *Request) WriteProxy(w io.Writer) error</pre>
			<p>WriteProxy is like Write but writes the request in the form
expected by an HTTP proxy.  In particular, WriteProxy writes the
initial Request-URI line of the request with an absolute URI, per
section 5.1.2 of RFC 2616, including the scheme and host.
In either case, WriteProxy also writes a Host header, using
either r.Host or r.URL.Host.
</p>
		
	
		<h3 id="Response">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/response.go?name=release#27">Response</a></h3>
		<pre class="pre-x-scrollable">type Response struct {
    Status     string // e.g. &#34;200 OK&#34;
    StatusCode int    // e.g. 200
    Proto      string // e.g. &#34;HTTP/1.0&#34;
    ProtoMajor int    // e.g. 1
    ProtoMinor int    // e.g. 0

    // Header maps header keys to values.  If the response had multiple
    // headers with the same key, they will be concatenated, with comma
    // delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers
    // be semantically equivalent to a comma-delimited sequence.) Values
    // duplicated by other fields in this struct (e.g., ContentLength) are
    // omitted from Header.
    //
    // Keys in the map are canonicalized (see CanonicalHeaderKey).
    Header Header

    // Body represents the response body.
    //
    // The http Client and Transport guarantee that Body is always
    // non-nil, even on responses without a body or responses with
    // a zero-lengthed body.
    Body io.ReadCloser

    // ContentLength records the length of the associated content.  The
    // value -1 indicates that the length is unknown.  Unless RequestMethod
    // is &#34;HEAD&#34;, values &gt;= 0 indicate that the given number of bytes may
    // be read from Body.
    ContentLength int64

    // Contains transfer encodings from outer-most to inner-most. Value is
    // nil, means that &#34;identity&#34; encoding is used.
    TransferEncoding []string

    // Close records whether the header directed that the connection be
    // closed after reading Body.  The value is advice for clients: neither
    // ReadResponse nor Response.Write ever closes a connection.
    Close bool

    // Trailer maps trailer keys to values, in the same
    // format as the header.
    Trailer Header

    // The Request that was sent to obtain this Response.
    // Request&#39;s Body is nil (having already been consumed).
    // This is only populated for Client requests.
    Request *Request
}</pre>
		<p>Response represents the response from an HTTP request.
</p>
		
			<h4 id="Get">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#176">Get</a></h4>
			<pre>func Get(url string) (resp *Response, err error)</pre>
			<p>Get issues a GET to the specified URL.  If the response is one of the following
redirect codes, Get follows the redirect, up to a maximum of 10 redirects:

   301 (Moved Permanently)
   302 (Found)
   303 (See Other)
   307 (Temporary Redirect)

An error is returned if there were too many redirects or if there
was an HTTP protocol error. A non-2xx response doesn&#39;t cause an
error.

When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.

Get is a wrapper around DefaultClient.Get.
</p>
		
			<h4 id="Head">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#350">Head</a></h4>
			<pre>func Head(url string) (resp *Response, err error)</pre>
			<p>Head issues a HEAD to the specified URL.  If the response is one of the
following redirect codes, Head follows the redirect after calling the
Client&#39;s CheckRedirect function.

   301 (Moved Permanently)
   302 (Found)
   303 (See Other)
   307 (Temporary Redirect)

Head is a wrapper around DefaultClient.Head
</p>
		
			<h4 id="Post">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#295">Post</a></h4>
			<pre>func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</pre>
			<p>Post issues a POST to the specified URL.

Caller should close resp.Body when done reading from it.

Post is a wrapper around DefaultClient.Post
</p>
		
			<h4 id="PostForm">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#327">PostForm</a></h4>
			<pre>func PostForm(url string, data url.Values) (resp *Response, err error)</pre>
			<p>PostForm issues a POST to the specified URL, with data&#39;s keys and
values URL-encoded as the request body.

When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.

PostForm is a wrapper around DefaultClient.PostForm
</p>
		
			<h4 id="ReadResponse">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/response.go?name=release#104">ReadResponse</a></h4>
			<pre>func ReadResponse(r *bufio.Reader, req *Request) (resp *Response, err error)</pre>
			<p>ReadResponse reads and returns an HTTP response from r.  The
req parameter specifies the Request that corresponds to
this Response.  Clients must call resp.Body.Close when finished
reading resp.Body.  After that call, clients can inspect
resp.Trailer to find key/value pairs included in the response
trailer.
</p>
		
		
			<h4 id="Cookies">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/response.go?name=release#77">Cookies</a></h4>
			<pre>func (r *Response) Cookies() []*Cookie</pre>
			<p>Cookies parses and returns the cookies set in the Set-Cookie headers.
</p>
		
			<h4 id="Location">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/response.go?name=release#87">Location</a></h4>
			<pre>func (r *Response) Location() (*url.URL, error)</pre>
			<p>Location returns the URL of the response&#39;s &#34;Location&#34; header,
if present.  Relative redirects are resolved relative to
the Response&#39;s Request.  ErrNoLocation is returned if no
Location header is present.
</p>
		
			<h4 id="ProtoAtLeast">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/response.go?name=release#171">ProtoAtLeast</a></h4>
			<pre>func (r *Response) ProtoAtLeast(major, minor int) bool</pre>
			<p>ProtoAtLeast returns whether the HTTP protocol used
in the response is at least major.minor.
</p>
		
			<h4 id="Write">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/response.go?name=release#189">Write</a></h4>
			<pre>func (r *Response) Write(w io.Writer) error</pre>
			<p>Writes the response (header, body and trailer) in wire format. This method
consults the following fields of the response:

 StatusCode
 ProtoMajor
 ProtoMinor
 RequestMethod
 TransferEncoding
 Trailer
 Body
 ContentLength
 Header, values for non-canonical keys will have unpredictable behavior
</p>
		
	
		<h3 id="ResponseWriter">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#53">ResponseWriter</a></h3>
		<pre class="pre-x-scrollable">type ResponseWriter interface {
    // Header returns the header map that will be sent by WriteHeader.
    // Changing the header after a call to WriteHeader (or Write) has
    // no effect.
    Header() Header

    // Write writes the data to the connection as part of an HTTP reply.
    // If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)
    // before writing the data.  If the Header does not contain a
    // Content-Type line, Write adds a Content-Type set to the result of passing
    // the initial 512 bytes of written data to DetectContentType.
    Write([]byte) (int, error)

    // WriteHeader sends an HTTP response header with status code.
    // If WriteHeader is not called explicitly, the first call to Write
    // will trigger an implicit WriteHeader(http.StatusOK).
    // Thus explicit calls to WriteHeader are mainly used to
    // send error codes.
    WriteHeader(int)
}</pre>
		<p>A ResponseWriter interface is used by an HTTP handler to
construct an HTTP response.
</p>
		
		
	
		<h3 id="RoundTripper">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release#60">RoundTripper</a></h3>
		<pre class="pre-x-scrollable">type RoundTripper interface {
    // RoundTrip executes a single HTTP transaction, returning
    // the Response for the request req.  RoundTrip should not
    // attempt to interpret the response.  In particular,
    // RoundTrip must return err == nil if it obtained a response,
    // regardless of the response&#39;s HTTP status code.  A non-nil
    // err should be reserved for failure to obtain a response.
    // Similarly, RoundTrip should not attempt to handle
    // higher-level protocol details such as redirects,
    // authentication, or cookies.
    //
    // RoundTrip should not modify the request, except for
    // consuming the Body.  The request&#39;s URL and Header fields
    // are guaranteed to be initialized.
    RoundTrip(*Request) (*Response, error)
}</pre>
		<p>RoundTripper is an interface representing the ability to execute a
single HTTP transaction, obtaining the Response for a given Request.

A RoundTripper must be safe for concurrent use by multiple
goroutines.
</p>
		
			<h4 id="NewFileTransport">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/filetransport.go?name=release#30">NewFileTransport</a></h4>
			<pre>func NewFileTransport(fs FileSystem) RoundTripper</pre>
			<p>NewFileTransport returns a new RoundTripper, serving the provided
FileSystem. The returned RoundTripper ignores the URL host in its
incoming requests, as well as most other properties of the
request.

The typical use case for NewFileTransport is to register the &#34;file&#34;
protocol with a Transport, as in:

  t := &amp;http.Transport{}
  t.RegisterProtocol(&#34;file&#34;, http.NewFileTransport(http.Dir(&#34;/&#34;)))
  c := &amp;http.Client{Transport: t}
  res, err := c.Get(&#34;file:///etc/passwd&#34;)
  ...
</p>
		
		
	
		<h3 id="ServeMux">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#851">ServeMux</a></h3>
		<pre class="pre-x-scrollable">type ServeMux struct {
    // contains filtered or unexported fields
}</pre>
		<p>ServeMux is an HTTP request multiplexer.
It matches the URL of each incoming request against a list of registered
patterns and calls the handler for the pattern that
most closely matches the URL.

Patterns name fixed, rooted paths, like &#34;/favicon.ico&#34;,
or rooted subtrees, like &#34;/images/&#34; (note the trailing slash).
Longer patterns take precedence over shorter ones, so that
if there are handlers registered for both &#34;/images/&#34;
and &#34;/images/thumbnails/&#34;, the latter handler will be
called for paths beginning &#34;/images/thumbnails/&#34; and the
former will receive requests for any other paths in the
&#34;/images/&#34; subtree.

Patterns may optionally begin with a host name, restricting matches to
URLs on that host only.  Host-specific patterns take precedence over
general patterns, so that a handler might register for the two patterns
&#34;/codesearch&#34; and &#34;codesearch.google.com/&#34; without also taking over
requests for &#34;http://www.google.com/&#34;.

ServeMux also takes care of sanitizing the URL request path,
redirecting any request containing . or .. elements to an
equivalent .- and ..-free URL.
</p>
		
			<h4 id="NewServeMux">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#862">NewServeMux</a></h4>
			<pre>func NewServeMux() *ServeMux</pre>
			<p>NewServeMux allocates and returns a new ServeMux.
</p>
		
		
			<h4 id="Handle">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#946">Handle</a></h4>
			<pre>func (mux *ServeMux) Handle(pattern string, handler Handler)</pre>
			<p>Handle registers the handler for the given pattern.
If a handler already exists for pattern, Handle panics.
</p>
		
			<h4 id="HandleFunc">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#972">HandleFunc</a></h4>
			<pre>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</pre>
			<p>HandleFunc registers the handler function for the given pattern.
</p>
		
			<h4 id="ServeHTTP">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#932">ServeHTTP</a></h4>
			<pre>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</pre>
			<p>ServeHTTP dispatches the request to the handler whose
pattern most closely matches the request URL.
</p>
		
	
		<h3 id="Server">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#998">Server</a></h3>
		<pre class="pre-x-scrollable">type Server struct {
    Addr           string        // TCP address to listen on, &#34;:http&#34; if empty
    Handler        Handler       // handler to invoke, http.DefaultServeMux if nil
    ReadTimeout    time.Duration // maximum duration before timing out read of the request
    WriteTimeout   time.Duration // maximum duration before timing out write of the response
    MaxHeaderBytes int           // maximum size of request headers, DefaultMaxHeaderBytes if 0
    TLSConfig      *tls.Config   // optional TLS config, used by ListenAndServeTLS
}</pre>
		<p>A Server defines parameters for running an HTTP server.
</p>
		
		
			<h4 id="ListenAndServe">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#1010">ListenAndServe</a></h4>
			<pre>func (srv *Server) ListenAndServe() error</pre>
			<p>ListenAndServe listens on the TCP network address srv.Addr and then
calls Serve to handle requests on incoming connections.  If
srv.Addr is blank, &#34;:http&#34; is used.
</p>
		
			<h4 id="ListenAndServeTLS">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#1136">ListenAndServeTLS</a></h4>
			<pre>func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error</pre>
			<p>ListenAndServeTLS listens on the TCP network address srv.Addr and
then calls Serve to handle requests on incoming TLS connections.

Filenames containing a certificate and matching private key for
the server must be provided. If the certificate is signed by a
certificate authority, the certFile should be the concatenation
of the server&#39;s certificate followed by the CA&#39;s certificate.

If srv.Addr is blank, &#34;:https&#34; is used.
</p>
		
			<h4 id="Serve">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release#1025">Serve</a></h4>
			<pre>func (srv *Server) Serve(l net.Listener) error</pre>
			<p>Serve accepts incoming connections on the Listener l, creating a
new service thread for each.  The service threads read requests and
then call srv.Handler to reply to them.
</p>
		
	
		<h3 id="Transport">type <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/transport.go?name=release#43">Transport</a></h3>
		<pre class="pre-x-scrollable">type Transport struct {

    // Proxy specifies a function to return a proxy for a given
    // Request. If the function returns a non-nil error, the
    // request is aborted with the provided error.
    // If Proxy is nil or returns a nil *URL, no proxy is used.
    Proxy func(*Request) (*url.URL, error)

    // Dial specifies the dial function for creating TCP
    // connections.
    // If Dial is nil, net.Dial is used.
    Dial func(net, addr string) (c net.Conn, err error)

    // TLSClientConfig specifies the TLS configuration to use with
    // tls.Client. If nil, the default configuration is used.
    TLSClientConfig *tls.Config

    DisableKeepAlives  bool
    DisableCompression bool

    // MaxIdleConnsPerHost, if non-zero, controls the maximum idle
    // (keep-alive) to keep to keep per-host.  If zero,
    // DefaultMaxIdleConnsPerHost is used.
    MaxIdleConnsPerHost int
    // contains filtered or unexported fields
}</pre>
		<p>Transport is an implementation of RoundTripper that supports http,
https, and http proxies (for either http or https with CONNECT).
Transport can also cache connections for future re-use.
</p>
		
		
			<h4 id="CloseIdleConnections">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/transport.go?name=release#189">CloseIdleConnections</a></h4>
			<pre>func (t *Transport) CloseIdleConnections()</pre>
			<p>CloseIdleConnections closes any connections which were previously
connected from previous requests but are now sitting idle in
a &#34;keep-alive&#34; state. It does not interrupt any connections currently
in use.
</p>
		
			<h4 id="RegisterProtocol">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/transport.go?name=release#170">RegisterProtocol</a></h4>
			<pre>func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)</pre>
			<p>RegisterProtocol registers a new protocol with scheme.
The Transport will pass requests using the given scheme to rt.
It is rt&#39;s responsibility to simulate HTTP request semantics.

RegisterProtocol can be used by other packages to provide
implementations of protocol schemes like &#34;ftp&#34; or &#34;file&#34;.
</p>
		
			<h4 id="RoundTrip">func <a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/transport.go?name=release#127">RoundTrip</a></h4>
			<pre>func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)</pre>
			<p>RoundTrip implements the RoundTripper interface.
</p>
		
	

<h3 id="_files"><a href="http://code.google.com/p/go/source/browse/src/pkg/net/http?name=release">Files</a></h3>
<p>


	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/fs.go?name=release">fs.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release">server.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/transfer.go?name=release">transfer.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/doc.go?name=release">doc.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/status.go?name=release">status.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/jar.go?name=release">jar.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/transport.go?name=release">transport.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/chunked.go?name=release">chunked.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/client.go?name=release">client.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/filetransport.go?name=release">filetransport.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/response.go?name=release">response.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/cookie.go?name=release">cookie.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/header.go?name=release">header.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/lex.go?name=release">lex.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/request.go?name=release">request.go</a>

	<a href="http://code.google.com/p/go/source/browse/src/pkg/net/http/sniff.go?name=release">sniff.go</a>


</p>
		</div>
		<div class="container">
			<div class="flat-well well-small">
				<a href="https://github.com/Unknwon">@Unknown</a>
				<span class="muted">|</span>
				<a href="mailto:joe2010xtmf@163.com">Feedback</a>
				<span class="muted">|</span>
				<a href="https://github.com/Unknwon/gowalker/issues">Website Issues</a>
				<span class="pull-right"><a href="#">Back to top</a></span>
			</div>
		</div>
		<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40109089-2', 'gowalker.org');
  ga('send', 'pageview');

</script>
	</body>
</html>